// Generated by rust-peg. Do not edit.
pub mod peg {
    #[allow(unused_imports)]
    use super::*;
    type Input = FlatTokenStream;
    type PositionRepr = <Input as ::peg::Parse>::PositionRepr;
    struct ParseState<'input> {
        _phantom: ::std::marker::PhantomData<&'input ()>,
        primary_cache: ::std::collections::HashMap<usize, ::peg::RuleResult<Expr>>,
    }
    impl<'input> ParseState<'input> {
        fn new() -> ParseState<'input> {
            ParseState {
                _phantom: ::std::marker::PhantomData,
                primary_cache: ::std::collections::HashMap::new(),
            }
        }
    }
    use crate::ast::Expr::*;
    use crate::ast::*;
    use crate::tokens::FlatTokenStream;
    use proc_macro2::{Delimiter, Ident, Literal, TokenStream};
    pub fn peg_grammar<'input>(
        __input: &'input Input,
    ) -> ::std::result::Result<Grammar, ::peg::error::ParseError<PositionRepr>> {
        #![allow(non_snake_case, unused)]
        let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
        let mut __state = ParseState::new();
        match __parse_peg_grammar(
            __input,
            &mut __state,
            &mut __err_state,
            ::peg::Parse::start(__input),
        ) {
            ::peg::RuleResult::Matched(__pos, __value) => {
                if __pos == __input.len() {
                    return Ok(__value);
                } else {
                    __err_state.mark_failure(__pos, "EOF");
                }
            }
            _ => (),
        }
        __state = ParseState::new();
        __err_state.reparse_for_error();
        match __parse_peg_grammar(
            __input,
            &mut __state,
            &mut __err_state,
            ::peg::Parse::start(__input),
        ) {
            ::peg::RuleResult::Matched(__pos, __value) => {
                if __pos == __input.len() {
                    panic!(
                        "Parser is nondeterministic: succeeded when reparsing for error position"
                    );
                } else {
                    __err_state.mark_failure(__pos, "EOF");
                }
            }
            _ => (),
        }
        Err(__err_state.into_parse_error(__input))
    }
    fn __parse_peg_grammar<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Grammar> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_rust_doc_comment(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, doc) => {
                    let __seq_res = __parse_rust_visibility(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, visibility) => {
                            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "grammar",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"grammar\"")
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res =
                                        __parse_IDENT(__input, __state, __err_state, __pos);
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, name) => {
                                            let __seq_res = __parse_grammar_args(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            );
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, args) => {
                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "for" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"for\"" ) } ;
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            let __seq_res = {
                                                                let str_start = __pos;
                                                                match match __parse_rust_type ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { :: peg :: RuleResult :: Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                            };
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    input_type,
                                                                ) => {
                                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"{\"" ) } ;
                                                                    match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_item ( __input , __state , __err_state , __pos ) ; match __step_res { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , :: peg :: RuleResult :: Failed => { break ; } } } :: peg :: RuleResult :: Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , items ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { Grammar { doc , visibility , name , args , input_type , items } } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_grammar_args<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<(Ident, TokenStream)>> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "(") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"(\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ",",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\",\"")
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res = {
                                let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, i) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, ":",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\":\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let str_start = __pos;
                                                    match match __parse_rust_type(
                                                        __input,
                                                        __state,
                                                        __err_state,
                                                        __pos,
                                                    ) {
                                                        ::peg::RuleResult::Matched(pos, _) => {
                                                            ::peg::RuleResult::Matched(pos, ())
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    } {
                                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                ::peg::ParseSlice::parse_slice(
                                                                    __input, str_start, __newpos,
                                                                ),
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, t) => {
                                                        ::peg::RuleResult::Matched(__pos, {
                                                            (i, t)
                                                        })
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, args) => {
                            let __seq_res = match match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ",",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\",\"")
                                }
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(__newpos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, ")",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\")\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, { args })
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_peg_rule<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Rule> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_rust_doc_comment(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, doc) => {
                    let __seq_res = __parse_cacheflag(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, cached) => {
                            let __seq_res =
                                __parse_rust_visibility(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, visibility) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "rule",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"rule\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res =
                                                __parse_IDENT(__input, __state, __err_state, __pos);
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, name) => {
                                                    let __seq_res = match __parse_rust_ty_params(
                                                        __input,
                                                        __state,
                                                        __err_state,
                                                        __pos,
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            Some(__value),
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Matched(__pos, None)
                                                        }
                                                    };
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            ty_params,
                                                        ) => {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = {
                                                                        let mut __repeat_pos =
                                                                            __pos;
                                                                        let mut __repeat_value =
                                                                            vec![];
                                                                        loop {
                                                                            let __pos =
                                                                                __repeat_pos;
                                                                            let __pos =
                                                                                if __repeat_value
                                                                                    .is_empty()
                                                                                {
                                                                                    __pos
                                                                                } else {
                                                                                    let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ;
                                                                                    match __sep_res { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { __newpos } , :: peg :: RuleResult :: Failed => break , }
                                                                                };
                                                                            let __step_res =
                                                                                __parse_rule_param(
                                                                                    __input,
                                                                                    __state,
                                                                                    __err_state,
                                                                                    __pos,
                                                                                );
                                                                            match __step_res { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                        }
                                                                        ::peg::RuleResult::Matched(
                                                                            __repeat_pos,
                                                                            __repeat_value,
                                                                        )
                                                                    };
                                                                    match __seq_res { :: peg :: RuleResult :: Matched ( __pos , params ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "->" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"->\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { :: peg :: RuleResult :: Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , t ) => { :: peg :: RuleResult :: Matched ( __pos , { t } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { :: peg :: RuleResult :: Matched ( __newpos , Some ( __value ) ) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched ( __pos , None ) } , } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , ret_type ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"=\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos ) ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , expr ) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\";\"" ) } { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { :: peg :: RuleResult :: Matched ( __newpos , ( ) ) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched ( __pos , ( ) ) } , } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { Rule { doc , name , ty_params , params , expr , ret_type , visibility , cached } } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_cacheflag<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<bool> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"#\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"[\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "cache",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"cache\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "]",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"]\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                ::peg::RuleResult::Matched(__pos, { true })
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, { false }),
            }
        }
    }
    fn __parse_rust_ty_params<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<TokenStream>> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"<\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ",",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\",\"")
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res = {
                                let str_start = __pos;
                                match {
                                    let __choice_res =
                                        match __parse_IDENT(__input, __state, __err_state, __pos) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => match __parse_LIFETIME(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        },
                                    }
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __newpos,
                                            ::peg::ParseSlice::parse_slice(
                                                __input, str_start, __newpos,
                                            ),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                        } else {
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, p) => {
                            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ">",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\">\"")
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    ::peg::RuleResult::Matched(__pos, { p })
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rule_param<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<RuleParam> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, name) => {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\":\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = {
                                let __choice_res = {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "rule",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"rule\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "<",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"<\"")
                                                    }
                                                };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    let __seq_res = {
                                                        let str_start = __pos;
                                                        match match __parse_rust_type(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        } {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                _,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                ::peg::ParseSlice::parse_slice(
                                                                    __input, str_start, __newpos,
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, r) => {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    { RuleParamTy::Rule(r) },
                                                                ),
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                };
                                match __choice_res {
                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                        ::peg::RuleResult::Matched(__pos, __value)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        let __seq_res = {
                                            let str_start = __pos;
                                            match match __parse_rust_type(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            ) {
                                                ::peg::RuleResult::Matched(pos, _) => {
                                                    ::peg::RuleResult::Matched(pos, ())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            } {
                                                ::peg::RuleResult::Matched(__newpos, _) => {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        ::peg::ParseSlice::parse_slice(
                                                            __input, str_start, __newpos,
                                                        ),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, t) => {
                                                ::peg::RuleResult::Matched(__pos, {
                                                    RuleParamTy::Rust(t)
                                                })
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, ty) => {
                                    ::peg::RuleResult::Matched(__pos, { RuleParam { name, ty } })
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_item<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Item> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_rust_use(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, u) => {
                        ::peg::RuleResult::Matched(__pos, { Item::Use(u) })
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = __parse_rust_var(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, v) => {
                                ::peg::RuleResult::Matched(__pos, { v })
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __seq_res = __parse_peg_rule(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, r) => {
                                    ::peg::RuleResult::Matched(__pos, { Item::Rule(r) })
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_rust_doc_comment<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Option<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match {
            let str_start = __pos;
            match {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"#\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"[\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "doc",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"doc\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "=",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"=\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_LITERAL(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "]" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"]\"" ) } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                ::peg::RuleResult::Matched(__pos, {
                                                                })
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        } {
            ::peg::RuleResult::Matched(__newpos, __value) => {
                ::peg::RuleResult::Matched(__newpos, Some(__value))
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
        }
    }
    fn __parse_rust_visibility<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Option<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match {
            let str_start = __pos;
            match {
                let __choice_res = {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "pub") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"pub\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = match match __parse_PAREN_GROUP(
                                __input,
                                __state,
                                __err_state,
                                __pos,
                            ) {
                                ::peg::RuleResult::Matched(pos, _) => {
                                    ::peg::RuleResult::Matched(pos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(__newpos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    ::peg::RuleResult::Matched(__pos, {})
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"crate\"")
                            }
                        }
                    }
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        } {
            ::peg::RuleResult::Matched(__newpos, __value) => {
                ::peg::RuleResult::Matched(__newpos, Some(__value))
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
        }
    }
    fn __parse_rust_use<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let str_start = __pos;
                match {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "use") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"use\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res =
                                match __parse_rust_path(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __choice_res = {
                                            let __seq_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "::",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"::\"")
                                                    }
                                                };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"*\"" ) } ;
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            ::peg::RuleResult::Matched(__pos, {})
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __choice_res {
                                            ::peg::RuleResult::Matched(__pos, __value) => {
                                                ::peg::RuleResult::Matched(__pos, __value)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                let __choice_res = {
                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"::\"" ) } ;
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"{\"" ) } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = {
                                                                        let mut __repeat_pos =
                                                                            __pos;
                                                                        let mut __repeat_value =
                                                                            vec![];
                                                                        loop {
                                                                            let __pos =
                                                                                __repeat_pos;
                                                                            let __pos =
                                                                                if __repeat_value
                                                                                    .is_empty()
                                                                                {
                                                                                    __pos
                                                                                } else {
                                                                                    let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ;
                                                                                    match __sep_res { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { __newpos } , :: peg :: RuleResult :: Failed => break , }
                                                                                };
                                                                            let __step_res = {
                                                                                let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                                match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "as" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"as\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { :: peg :: RuleResult :: Matched ( __newpos , ( ) ) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched ( __pos , ( ) ) } , } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                            };
                                                                            match __step_res { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                        }
                                                                        if __repeat_value.len() >= 1
                                                                        {
                                                                            :: peg :: RuleResult :: Matched ( __repeat_pos , ( ) )
                                                                        } else {
                                                                            :: peg :: RuleResult :: Failed
                                                                        }
                                                                    };
                                                                    match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __choice_res {
                                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                                        ::peg::RuleResult::Matched(__pos, __value)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        match {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "as" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"as\"" ) } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                    match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        } {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                _,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                (),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    (),
                                                                )
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, ";",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\";\"")
                                                    }
                                                };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    ::peg::RuleResult::Matched(__pos, {})
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                        __newpos,
                        ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, v) => {
                    ::peg::RuleResult::Matched(__pos, { v.to_owned() })
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_var<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Item> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, name) => {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\":\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = {
                                let str_start = __pos;
                                match match __parse_rust_type(__input, __state, __err_state, __pos)
                                {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __newpos,
                                            ::peg::ParseSlice::parse_slice(
                                                __input, str_start, __newpos,
                                            ),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, rt) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, ";",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\";\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, {
                                                Item::MemberVariable(name, rt.to_owned())
                                            })
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_path<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match {
                let __seq_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"crate\""),
                    };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "::") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"::\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                ::peg::RuleResult::Matched(__pos, {})
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(__newpos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "::",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"::\"")
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res =
                                match __parse_IDENT(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            ::peg::RuleResult::Matched(__repeat_pos, ())
                        } else {
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            ::peg::RuleResult::Matched(__pos, {})
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_type<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match __parse_BRACKET_GROUP(__input, __state, __err_state, __pos) {
                ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"&\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res =
                                    match match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "mut",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"mut\"")
                                        }
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(__newpos, ())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = match match __parse_LIFETIME(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        } {
                                            ::peg::RuleResult::Matched(__newpos, _) => {
                                                ::peg::RuleResult::Matched(__newpos, ())
                                            }
                                            ::peg::RuleResult::Failed => {
                                                ::peg::RuleResult::Matched(__pos, ())
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, {})
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "dyn",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"dyn\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = match __parse_rust_type(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                ::peg::RuleResult::Matched(__pos, {})
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "impl",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"impl\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, {})
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = match __parse_IDENT(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"<\"" ) } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = {
                                                                    let mut __repeat_pos = __pos;
                                                                    let mut __repeat_value = vec![];
                                                                    loop {
                                                                        let __pos = __repeat_pos;
                                                                        let __pos =
                                                                            if __repeat_value
                                                                                .is_empty()
                                                                            {
                                                                                __pos
                                                                            } else {
                                                                                let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ;
                                                                                match __sep_res { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { __newpos } , :: peg :: RuleResult :: Failed => break , }
                                                                            };
                                                                        let __step_res = {
                                                                            let __choice_res = match __parse_LIFETIME ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                            match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => match __parse_rust_type ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } }
                                                                        };
                                                                        match __step_res { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                    }
                                                                    if __repeat_value.len() >= 1 {
                                                                        ::peg::RuleResult::Matched(
                                                                            __repeat_pos,
                                                                            (),
                                                                        )
                                                                    } else {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                };
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ;
                                                                        match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    let __choice_res = {
                                                        let __seq_res = match __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"::\"" ) } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                        match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __choice_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos, __value,
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            let __choice_res = {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = {
                                                                            let mut __repeat_pos =
                                                                                __pos;
                                                                            let mut __repeat_value =
                                                                                vec![];
                                                                            loop {
                                                                                let __pos =
                                                                                    __repeat_pos;
                                                                                let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __sep_res { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ;
                                                                                let __step_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                                match __step_res { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                            }
                                                                            :: peg :: RuleResult :: Matched ( __repeat_pos , ( ) )
                                                                        };
                                                                        match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            };
                                                            match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => match __parse_IDENT ( __input , __state , __err_state , __pos ) { :: peg :: RuleResult :: Matched ( pos , _ ) => :: peg :: RuleResult :: Matched ( pos , ( ) ) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_expression<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        __parse_choice(__input, __state, __err_state, __pos)
    }
    fn __parse_choice<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __pos = if __repeat_value.is_empty() {
                        __pos
                    } else {
                        let __sep_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "/") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"/\"")
                                }
                            };
                        match __sep_res {
                            ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                            ::peg::RuleResult::Failed => break,
                        }
                    };
                    let __step_res = __parse_sequence(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                } else {
                    ::peg::RuleResult::Failed
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, s) => ::peg::RuleResult::Matched(__pos, {
                    if s.len() == 1 {
                        s.into_iter().next().unwrap()
                    } else {
                        ChoiceExpr(s)
                    }
                }),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_sequence<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_labeled(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, elements) => {
                    let __seq_res = match __parse_code_block(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            ::peg::RuleResult::Matched(__newpos, Some(__value))
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, code) => {
                            ::peg::RuleResult::Matched(__pos, {
                                if let Some(code) = code {
                                    ActionExpr(elements, Some(code.1), code.0)
                                } else if elements.len() != 1 {
                                    ActionExpr(elements, None, false)
                                } else {
                                    elements.into_iter().next().unwrap().expr
                                }
                            })
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_code_block<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<(bool, TokenStream)> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "{") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"{\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = match match ::peg::ParseLiteral::parse_string_literal(
                        __input, __pos, "?",
                    ) {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"?\""),
                    } {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            ::peg::RuleResult::Matched(__newpos, Some(__value))
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, is_cond) => {
                            let __seq_res = __input.group_body(__pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, code) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "}",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"}\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, {
                                                (is_cond.is_some(), code)
                                            })
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_labeled<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TaggedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match {
                let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, l) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\":\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                ::peg::RuleResult::Matched(__pos, { l })
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            } {
                ::peg::RuleResult::Matched(__newpos, __value) => {
                    ::peg::RuleResult::Matched(__newpos, Some(__value))
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, label) => {
                    let __seq_res = __parse_suffixed(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, expression) => {
                            ::peg::RuleResult::Matched(__pos, {
                                TaggedExpr {
                                    name: label,
                                    expr: expression,
                                }
                            })
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_suffixed<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_prefixed(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, e) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "?") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"?\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                ::peg::RuleResult::Matched(__pos, { OptionalExpr(Box::new(e)) })
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = __parse_prefixed(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, e) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "**",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"**\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = __parse_repeatcount(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        );
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, count) => {
                                                let __seq_res = __parse_primary(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, sep) => {
                                                        ::peg::RuleResult::Matched(__pos, {
                                                            Repeat(
                                                                Box::new(e),
                                                                count,
                                                                Some(Box::new(sep)),
                                                            )
                                                        })
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res =
                                    __parse_prefixed(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, e) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "++",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"++\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = __parse_primary(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, sep) => {
                                                        ::peg::RuleResult::Matched(__pos, {
                                                            Repeat(
                                                                Box::new(e),
                                                                BoundedRepeat::Plus,
                                                                Some(Box::new(sep)),
                                                            )
                                                        })
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            __parse_prefixed(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, e) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "*",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"*\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_repeatcount(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                count,
                                                            ) => {
                                                                ::peg::RuleResult::Matched(__pos, {
                                                                    Repeat(Box::new(e), count, None)
                                                                })
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = __parse_prefixed(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, e) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "+" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"+\"" ) } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                ::peg::RuleResult::Matched(__pos, {
                                                                    Repeat(
                                                                        Box::new(e),
                                                                        BoundedRepeat::Plus,
                                                                        None,
                                                                    )
                                                                })
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => __parse_prefixed(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ),
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_repeatcount<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<BoundedRepeat> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"<\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = __parse_repeatnum(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, n) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ">",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\">\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(__pos, {
                                            BoundedRepeat::Exact(n)
                                        })
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"<\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res =
                                    match __parse_repeatnum(__input, __state, __err_state, __pos) {
                                        ::peg::RuleResult::Matched(__newpos, __value) => {
                                            ::peg::RuleResult::Matched(__newpos, Some(__value))
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, None)
                                        }
                                    };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, min) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, ",",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\",\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_repeatnum(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        __value,
                                                    ) => ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        Some(__value),
                                                    ),
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Matched(__pos, None)
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, max) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                ::peg::RuleResult::Matched(__pos, {
                                                                    BoundedRepeat::Both(min, max)
                                                                })
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            ::peg::RuleResult::Matched(__pos, { BoundedRepeat::None })
                        }
                    }
                }
            }
        }
    }
    fn __parse_repeatnum<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        {
            let str_start = __pos;
            match {
                let __choice_res = match __parse_INTEGER(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match __parse_BRACE_GROUP(__input, __state, __err_state, __pos) {
                            ::peg::RuleResult::Matched(pos, _) => {
                                ::peg::RuleResult::Matched(pos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_prefixed<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "$")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"$\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = __parse_primary(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, expression) => {
                                ::peg::RuleResult::Matched(__pos, {
                                    MatchStrExpr(Box::new(expression))
                                })
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"&\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res =
                                    __parse_primary(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, expression) => {
                                        ::peg::RuleResult::Matched(__pos, {
                                            PosAssertExpr(Box::new(expression))
                                        })
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "!",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"!\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            __parse_primary(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, expression) => {
                                                ::peg::RuleResult::Matched(__pos, {
                                                    NegAssertExpr(Box::new(expression))
                                                })
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    __parse_primary(__input, __state, __err_state, __pos)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_primary<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        if let Some(entry) = __state.primary_cache.get(&__pos) {
            return entry.clone();
        }
        let __rule_result = {
            let __choice_res = {
                let __seq_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "precedence") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"precedence\"")
                        }
                    };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "!") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"!\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "{",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"{\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __pos = if __repeat_value.is_empty() {
                                                    __pos
                                                } else {
                                                    let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "--" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"--\"" ) } ;
                                                    match __sep_res {
                                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                                            __newpos
                                                        }
                                                        ::peg::RuleResult::Failed => break,
                                                    }
                                                };
                                                let __step_res = __parse_precedence_level(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __step_res {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        __value,
                                                    ) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, levels) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "}",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"}\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, {
                                                            PrecedenceExpr { levels: levels }
                                                        })
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                            __input, __pos, "position",
                        ) {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"position\"")
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "!",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"!\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "(",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"(\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, ")",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\")\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, {
                                                            PositionExpr
                                                        })
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "quiet",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"quiet\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "!",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"!\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "{",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"{\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_expression(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                e,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            {
                                                                                QuietExpr(Box::new(
                                                                                    e,
                                                                                ))
                                                                            },
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "expected",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"expected\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "!",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"!\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = __parse_LITERAL(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        s,
                                                                    ) => {
                                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ;
                                                                        match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { FailExpr ( s ) } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = {
                                                    __err_state.suppress_fail += 1;
                                                    let __assert_res = {
                                                        let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "_" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"_\"" ) } ;
                                                        match __choice_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                __value,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "__" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"__\"" ) } ;
                                                                match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "___" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"___\"" ) } }
                                                            }
                                                        }
                                                    };
                                                    __err_state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        ::peg::RuleResult::Matched(_, __value) => {
                                                            ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                name,
                                                            ) => {
                                                                ::peg::RuleResult::Matched(__pos, {
                                                                    RuleExpr(name, Vec::new())
                                                                })
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    let __choice_res = {
                                                        let __seq_res = __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                name,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = {
                                                                            let mut __repeat_pos =
                                                                                __pos;
                                                                            let mut __repeat_value =
                                                                                vec![];
                                                                            loop {
                                                                                let __pos =
                                                                                    __repeat_pos;
                                                                                let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __sep_res { :: peg :: RuleResult :: Matched ( __newpos , _ ) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ;
                                                                                let __step_res = __parse_rule_arg ( __input , __state , __err_state , __pos ) ;
                                                                                match __step_res { :: peg :: RuleResult :: Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                            }
                                                                            :: peg :: RuleResult :: Matched ( __repeat_pos , __repeat_value )
                                                                        };
                                                                        match __seq_res { :: peg :: RuleResult :: Matched ( __pos , args ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { RuleExpr ( name , args ) } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __choice_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos, __value,
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            let __choice_res = {
                                                                let __seq_res = __parse_LITERAL(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        l,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            { LiteralExpr(l) },
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            };
                                                            match __choice_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    __value,
                                                                ) => ::peg::RuleResult::Matched(
                                                                    __pos, __value,
                                                                ),
                                                                ::peg::RuleResult::Failed => {
                                                                    let __choice_res = {
                                                                        let __seq_res =
                                                                            __parse_BRACKET_GROUP(
                                                                                __input,
                                                                                __state,
                                                                                __err_state,
                                                                                __pos,
                                                                            );
                                                                        match __seq_res { :: peg :: RuleResult :: Matched ( __pos , p ) => { :: peg :: RuleResult :: Matched ( __pos , { PatternExpr ( p ) } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    };
                                                                    match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "@" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"@\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { MarkerExpr ( true ) } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "@" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"@\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { MarkerExpr ( false ) } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "##" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"##\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , method ) => { { let __seq_res = __parse_PAREN_GROUP ( __input , __state , __err_state , __pos ) ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , args ) => { :: peg :: RuleResult :: Matched ( __pos , { MethodExpr ( method , args ) } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched ( __pos , __value ) => :: peg :: RuleResult :: Matched ( __pos , __value ) , :: peg :: RuleResult :: Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos ) ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , expression ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { :: peg :: RuleResult :: Matched ( __pos , __val ) => :: peg :: RuleResult :: Matched ( __pos , __val ) , :: peg :: RuleResult :: Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { :: peg :: RuleResult :: Matched ( __pos , _ ) => { :: peg :: RuleResult :: Matched ( __pos , { expression } ) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } } } } } } }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        __state.primary_cache.insert(__pos, __rule_result.clone());
        __rule_result
    }
    fn __parse_rule_arg<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<RuleArg> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"<\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = __parse_expression(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, e) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ">",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\">\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(__pos, { RuleArg::Peg(e) })
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __seq_res = {
                        let str_start = __pos;
                        match {
                            let __choice_res =
                                match __parse_LITERAL(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = match __parse_PAREN_GROUP(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => match __parse_IDENT(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        },
                                    }
                                }
                            }
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                                __newpos,
                                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                            ),
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, tt) => {
                            ::peg::RuleResult::Matched(__pos, { RuleArg::Rust(tt) })
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
            }
        }
    }
    fn __parse_precedence_level<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<PrecedenceLevel> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_precedence_op(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                } else {
                    ::peg::RuleResult::Failed
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, operators) => {
                    ::peg::RuleResult::Matched(__pos, {
                        PrecedenceLevel {
                            operators: operators,
                        }
                    })
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_precedence_op<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<PrecedenceOperator> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_labeled(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, elements) => {
                    let __seq_res = __parse_BRACE_GROUP(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, action) => {
                            ::peg::RuleResult::Matched(__pos, {
                                PrecedenceOperator { elements, action }
                            })
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_KEYWORD<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res =
                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "pub") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"pub\""),
                };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"crate\"")
                            }
                        };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "rule",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"rule\"")
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res =
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "use",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                ::peg::RuleResult::Matched(__pos, __val)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"use\"")
                                            }
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "type",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"type\"")
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_IDENT<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Ident> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                __err_state.suppress_fail += 1;
                let __assert_res = match __parse_KEYWORD(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                __err_state.suppress_fail -= 1;
                match __assert_res {
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                    ::peg::RuleResult::Matched(..) => ::peg::RuleResult::Failed,
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = __input.ident(__pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, i) => {
                            ::peg::RuleResult::Matched(__pos, { i })
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_LITERAL<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Literal> {
        #![allow(non_snake_case, unused)]
        __input.literal(__pos)
    }
    fn __parse_PAREN_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Parenthesis)
    }
    fn __parse_BRACE_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Brace)
    }
    fn __parse_BRACKET_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Bracket)
    }
    fn __parse_LIFETIME<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "'") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"'\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = match __parse_IDENT(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            ::peg::RuleResult::Matched(__pos, {})
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_INTEGER<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        match __parse_LITERAL(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
    }
}
