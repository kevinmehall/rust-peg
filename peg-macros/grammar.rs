// Generated by rust-peg. Do not edit.
pub mod peg {
    #[allow(unused_imports)]
    use super::*;
    type Input = FlatTokenStream;
    type PositionRepr = <Input as ::peg::Parse>::PositionRepr;
    struct ParseState<'input> {
        _phantom: ::std::marker::PhantomData<&'input ()>,
        primary_cache: ::std::collections::HashMap<usize, ::peg::RuleResult<SpannedExpr>>,
    }
    impl<'input> ParseState<'input> {
        fn new() -> ParseState<'input> {
            ParseState {
                _phantom: ::std::marker::PhantomData,
                primary_cache: ::std::collections::HashMap::new(),
            }
        }
    }
    use crate::ast::Expr::*;
    use crate::ast::*;
    use crate::tokens::FlatTokenStream;
    use proc_macro2::{Delimiter, Group, Ident, Literal, Span, TokenStream};
    pub fn peg_grammar<'input>(
        __input: &'input Input,
    ) -> ::std::result::Result<Grammar, ::peg::error::ParseError<PositionRepr>> {
        #![allow(non_snake_case, unused)]
        let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
        let mut __state = ParseState::new();
        match __parse_peg_grammar(
            __input,
            &mut __state,
            &mut __err_state,
            ::peg::Parse::start(__input),
        ) {
            ::peg::RuleResult::Matched(__pos, __value) => {
                if ::peg::Parse::is_eof(__input, __pos) {
                    return Ok(__value);
                } else {
                    __err_state.mark_failure(__pos, "EOF");
                }
            }
            _ => (),
        }
        __state = ParseState::new();
        __err_state.reparse_for_error();
        match __parse_peg_grammar(
            __input,
            &mut __state,
            &mut __err_state,
            ::peg::Parse::start(__input),
        ) {
            ::peg::RuleResult::Matched(__pos, __value) => {
                if ::peg::Parse::is_eof(__input, __pos) {
                    panic!(
                        "Parser is nondeterministic: succeeded when reparsing for error position"
                    );
                } else {
                    __err_state.mark_failure(__pos, "EOF");
                }
            }
            _ => (),
        }
        Err(__err_state.into_parse_error(__input))
    }
    fn __parse_peg_grammar<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Grammar> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_rust_doc_comment(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, doc) => {
                    let __seq_res = __parse_rust_visibility(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, visibility) => {
                            match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "grammar",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    let __seq_res =
                                        __parse_IDENT(__input, __state, __err_state, __pos);
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, name) => {
                                            let __seq_res = match __parse_rust_ty_params(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            ) {
                                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        Some(__value),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Matched(__pos, None)
                                                }
                                            };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, ty_params) => {
                                                    let __seq_res = __parse_grammar_args(
                                                        __input,
                                                        __state,
                                                        __err_state,
                                                        __pos,
                                                    );
                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , args) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "for") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , :: peg :: ParseSlice :: parse_slice (__input , str_start , __newpos)) } , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , input_type) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "{") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! () ; loop { let __pos = __repeat_pos ; let __step_res = __parse_item (__input , __state , __err_state , __pos) ; match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } } } :: peg :: RuleResult :: Matched (__repeat_pos , __repeat_value) } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , items) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { Grammar { doc , visibility , name , ty_params , args , input_type , items } }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"}\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"{\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"for\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"grammar\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_grammar_args<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<(Ident, TokenStream)>> {
        #![allow(non_snake_case, unused)]
        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "(") {
            ::peg::RuleResult::Matched(__pos, __val) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.is_empty() {
                            __pos
                        } else {
                            let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ",",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\",\"");
                                    ::peg::RuleResult::Failed
                                }
                            };
                            match __sep_res {
                                ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                ::peg::RuleResult::Failed => break,
                            }
                        };
                        let __step_res = {
                            let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, i) => {
                                    match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, ":",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            let __seq_res = {
                                                let str_start = __pos;
                                                match match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                } {
                                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            ::peg::ParseSlice::parse_slice(
                                                                __input, str_start, __newpos,
                                                            ),
                                                        )
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, t) => {
                                                    ::peg::RuleResult::Matched(__pos, (|| (i, t))())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\":\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __step_res {
                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            ::peg::RuleResult::Failed => {
                                break;
                            }
                        }
                    }
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, args) => {
                        let __seq_res = match match ::peg::ParseLiteral::parse_string_literal(
                            __input, __pos, ",",
                        ) {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\",\"");
                                ::peg::RuleResult::Failed
                            }
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => {
                                ::peg::RuleResult::Matched(__newpos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ")")
                                {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, (|| args)())
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\")\"");
                                        ::peg::RuleResult::Failed
                                    }
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
            ::peg::RuleResult::Failed => {
                __err_state.mark_failure(__pos, "\"(\"");
                ::peg::RuleResult::Failed
            }
        }
    }
    fn __parse_peg_rule<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Rule> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_rust_doc_comment(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, doc) => {
                    let __seq_res = __parse_cacheflag(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, cached) => {
                            let __seq_res =
                                __parse_no_eof_flag(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, no_eof) => {
                                    let __seq_res = __parse_rust_visibility(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    );
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, visibility) => {
                                            let __seq_res =
                                                __parse_sp(__input, __state, __err_state, __pos);
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, span) => {
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "rule",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            let __seq_res = {
                                                                let __choice_res = {
                                                                    let __seq_res = {
                                                                        __err_state
                                                                            .suppress_fail += 1;
                                                                        let __assert_res = {
                                                                            let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "_") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"_\"") ; :: peg :: RuleResult :: Failed } } ;
                                                                            match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "__") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"__\"") ; :: peg :: RuleResult :: Failed } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "___") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"___\"") ; :: peg :: RuleResult :: Failed } } } } }
                                                                        };
                                                                        __err_state
                                                                            .suppress_fail -= 1;
                                                                        match __assert_res { :: peg :: RuleResult :: Matched (_ , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    };
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = __parse_IDENT (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , name) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { (name , None , Vec :: new ()) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                };
                                                                match __choice_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        __value,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos, __value,
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        let __seq_res =
                                                                            __parse_IDENT(
                                                                                __input,
                                                                                __state,
                                                                                __err_state,
                                                                                __pos,
                                                                            );
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , name) => { { let __seq_res = match __parse_rust_ty_params (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (__newpos , __value) => { :: peg :: RuleResult :: Matched (__newpos , Some (__value)) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , None) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , ty_params) => { { let __seq_res = __parse_rule_params (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , params) => { :: peg :: RuleResult :: Matched (__pos , (|| { (name , ty_params , params) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                }
                                                            };
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    header,
                                                                ) => {
                                                                    let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "->") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , :: peg :: ParseSlice :: parse_slice (__input , str_start , __newpos)) } , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , t) => { :: peg :: RuleResult :: Matched (__pos , (|| { t }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"->\"") ; :: peg :: RuleResult :: Failed } } { :: peg :: RuleResult :: Matched (__newpos , __value) => { :: peg :: RuleResult :: Matched (__newpos , Some (__value)) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , None) } , } ;
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , ret_type) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "=") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_expression (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , expr) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ";") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\";\"") ; :: peg :: RuleResult :: Failed } } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { Rule { span , doc , name : header . 0 , ty_params : header . 1 , params : header . 2 , expr , ret_type , visibility , no_eof , cached } }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"=\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state
                                                                .mark_failure(__pos, "\"rule\"");
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_cacheflag<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<bool> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#")
            {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "cache")
                            {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "]",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, (|| true)())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"]\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"cache\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"[\"");
                            ::peg::RuleResult::Failed
                        }
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"#\"");
                    ::peg::RuleResult::Failed
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, (|| false)()),
            }
        }
    }
    fn __parse_no_eof_flag<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<bool> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#")
            {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "no_eof",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "]",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, (|| true)())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"]\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"no_eof\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"[\"");
                            ::peg::RuleResult::Failed
                        }
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"#\"");
                    ::peg::RuleResult::Failed
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, (|| false)()),
            }
        }
    }
    fn __parse_rust_ty_params<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
            ::peg::RuleResult::Matched(__pos, __val) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.is_empty() {
                            __pos
                        } else {
                            let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ",",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\",\"");
                                    ::peg::RuleResult::Failed
                                }
                            };
                            match __sep_res {
                                ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                ::peg::RuleResult::Failed => break,
                            }
                        };
                        let __step_res = {
                            let str_start = __pos;
                            match {
                                let __choice_res =
                                    match __parse_IDENT(__input, __state, __err_state, __pos) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                match __choice_res {
                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                        ::peg::RuleResult::Matched(__pos, __value)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        match __parse_LIFETIME(__input, __state, __err_state, __pos)
                                        {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                }
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(
                                        __newpos,
                                        ::peg::ParseSlice::parse_slice(
                                            __input, str_start, __newpos,
                                        ),
                                    )
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __step_res {
                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            ::peg::RuleResult::Failed => {
                                break;
                            }
                        }
                    }
                    if __repeat_value.len() >= 1 {
                        ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                    } else {
                        ::peg::RuleResult::Failed
                    }
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, p) => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ">") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, (|| p)())
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\">\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
            ::peg::RuleResult::Failed => {
                __err_state.mark_failure(__pos, "\"<\"");
                ::peg::RuleResult::Failed
            }
        }
    }
    fn __parse_rule_param_ty<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<RuleParamTy> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res =
                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "rule") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                let __seq_res = {
                                    let str_start = __pos;
                                    match match __parse_rust_type(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(
                                                __newpos,
                                                ::peg::ParseSlice::parse_slice(
                                                    __input, str_start, __newpos,
                                                ),
                                            )
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, r) => {
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, ">",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                ::peg::RuleResult::Matched(
                                                    __pos,
                                                    (|| RuleParamTy::Rule(r))(),
                                                )
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\">\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"<\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => {
                        __err_state.mark_failure(__pos, "\"rule\"");
                        ::peg::RuleResult::Failed
                    }
                };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __seq_res = {
                        let str_start = __pos;
                        match match __parse_rust_type(__input, __state, __err_state, __pos) {
                            ::peg::RuleResult::Matched(pos, _) => {
                                ::peg::RuleResult::Matched(pos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                                __newpos,
                                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                            ),
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, t) => {
                            ::peg::RuleResult::Matched(__pos, (|| RuleParamTy::Rust(t))())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
            }
        }
    }
    fn __parse_rule_params<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<RuleParam>> {
        #![allow(non_snake_case, unused)]
        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "(") {
            ::peg::RuleResult::Matched(__pos, __val) => {
                let __seq_res = {
                    let mut __repeat_pos = __pos;
                    let mut __repeat_value = vec![];
                    loop {
                        let __pos = __repeat_pos;
                        let __pos = if __repeat_value.is_empty() {
                            __pos
                        } else {
                            let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ",",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\",\"");
                                    ::peg::RuleResult::Failed
                                }
                            };
                            match __sep_res {
                                ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                ::peg::RuleResult::Failed => break,
                            }
                        };
                        let __step_res = {
                            let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, name) => {
                                    match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, ":",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            let __seq_res = __parse_rule_param_ty(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            );
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, ty) => {
                                                    ::peg::RuleResult::Matched(
                                                        __pos,
                                                        (|| RuleParam { name, ty })(),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\":\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __step_res {
                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                __repeat_pos = __newpos;
                                __repeat_value.push(__value);
                            }
                            ::peg::RuleResult::Failed => {
                                break;
                            }
                        }
                    }
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, params) => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ")") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, (|| params)())
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\")\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
            ::peg::RuleResult::Failed => {
                __err_state.mark_failure(__pos, "\"(\"");
                ::peg::RuleResult::Failed
            }
        }
    }
    fn __parse_item<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Item> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_rust_use(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, u) => {
                        ::peg::RuleResult::Matched(__pos, (|| Item::Use(u))())
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __seq_res = __parse_peg_rule(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, r) => {
                            ::peg::RuleResult::Matched(__pos, (|| Item::Rule(r))())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
            }
        }
    }
    fn __parse_rust_doc_comment<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Option<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = match ::peg::ParseLiteral::parse_string_literal(
                        __input, __pos, "#",
                    ) {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "doc",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "=",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    let __seq_res = match __parse_LITERAL(
                                                        __input,
                                                        __state,
                                                        __err_state,
                                                        __pos,
                                                    ) {
                                                        ::peg::RuleResult::Matched(pos, _) => {
                                                            ::peg::RuleResult::Matched(pos, ())
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    };
                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "]") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"]\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"=\"");
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"doc\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"[\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"#\"");
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                ::peg::RuleResult::Matched(__repeat_pos, ())
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        } {
            ::peg::RuleResult::Matched(__newpos, __value) => {
                ::peg::RuleResult::Matched(__newpos, Some(__value))
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
        }
    }
    fn __parse_rust_visibility<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Option<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match {
            let str_start = __pos;
            match {
                let __choice_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "pub") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            let __seq_res = match match __parse_PAREN_GROUP(
                                __input,
                                __state,
                                __err_state,
                                __pos,
                            ) {
                                ::peg::RuleResult::Matched(pos, _) => {
                                    ::peg::RuleResult::Matched(pos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(__newpos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    ::peg::RuleResult::Matched(__pos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"pub\"");
                            ::peg::RuleResult::Failed
                        }
                    };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"crate\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        } {
            ::peg::RuleResult::Matched(__newpos, __value) => {
                ::peg::RuleResult::Matched(__newpos, Some(__value))
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
        }
    }
    fn __parse_rust_use<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let str_start = __pos;
                match match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "use") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        let __seq_res =
                            match __parse_rust_path(__input, __state, __err_state, __pos) {
                                ::peg::RuleResult::Matched(pos, _) => {
                                    ::peg::RuleResult::Matched(pos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = {
                                    let __choice_res =
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "::",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "*",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"*\"");
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"::\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "::") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "{") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! () ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty () { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\",\"") ; :: peg :: RuleResult :: Failed } } ; match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ; let __step_res = { let __seq_res = match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "as") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"as\"") ; :: peg :: RuleResult :: Failed } } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } } } if __repeat_value . len () >= 1 { :: peg :: RuleResult :: Matched (__repeat_pos , ()) } else { :: peg :: RuleResult :: Failed } } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"}\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"{\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"::\"") ; :: peg :: RuleResult :: Failed } } ;
                                            match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "as") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"as\"") ; :: peg :: RuleResult :: Failed } } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } , } }
                                        }
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, ";",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                ::peg::RuleResult::Matched(__pos, ())
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\";\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => {
                        __err_state.mark_failure(__pos, "\"use\"");
                        ::peg::RuleResult::Failed
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                        __newpos,
                        ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, v) => {
                    ::peg::RuleResult::Matched(__pos, (|| v.to_owned())())
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_path<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res =
                match match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "::") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, ())
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"::\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => {
                        __err_state.mark_failure(__pos, "\"crate\"");
                        ::peg::RuleResult::Failed
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, _) => {
                        ::peg::RuleResult::Matched(__newpos, ())
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "::",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"::\"");
                                        ::peg::RuleResult::Failed
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res =
                                match __parse_IDENT(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            ::peg::RuleResult::Matched(__repeat_pos, ())
                        } else {
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            ::peg::RuleResult::Matched(__pos, ())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_type<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match __parse_BRACKET_GROUP(__input, __state, __err_state, __pos) {
                ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                let __seq_res =
                                    match match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "mut",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"mut\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(__newpos, ())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = match match __parse_LIFETIME(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        } {
                                            ::peg::RuleResult::Matched(__newpos, _) => {
                                                ::peg::RuleResult::Matched(__newpos, ())
                                            }
                                            ::peg::RuleResult::Failed => {
                                                ::peg::RuleResult::Matched(__pos, ())
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"&\"");
                                ::peg::RuleResult::Failed
                            }
                        };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "dyn",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    let __seq_res = match __parse_rust_type(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"dyn\"");
                                    ::peg::RuleResult::Failed
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res =
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "impl",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                let __seq_res = match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"impl\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = match __parse_IDENT(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "<") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! () ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty () { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\",\"") ; :: peg :: RuleResult :: Failed } } ; match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ; let __step_res = { let __choice_res = match __parse_LIFETIME (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } ; match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } } } if __repeat_value . len () >= 1 { :: peg :: RuleResult :: Matched (__repeat_pos , ()) } else { :: peg :: RuleResult :: Failed } } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ">") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\">\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"<\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    let __choice_res = {
                                                        let __seq_res = match __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "::") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"::\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                    };
                                                    match __choice_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos, __value,
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! () ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty () { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\",\"") ; :: peg :: RuleResult :: Failed } } ; match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ; let __step_res = match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } } } :: peg :: RuleResult :: Matched (__repeat_pos , ()) } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } ;
                                                            match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_expression<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<SpannedExpr> {
        #![allow(non_snake_case, unused)]
        __parse_choice(__input, __state, __err_state, __pos)
    }
    fn __parse_choice<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<SpannedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, sp) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "/",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"/\"");
                                        ::peg::RuleResult::Failed
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res = __parse_sequence(__input, __state, __err_state, __pos);
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                        } else {
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, s) => ::peg::RuleResult::Matched(
                            __pos,
                            (|| {
                                if s.len() == 1 {
                                    s.into_iter().next().unwrap()
                                } else {
                                    ChoiceExpr(s).at(sp)
                                }
                            })(),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_sequence<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<SpannedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, sp) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_labeled(__input, __state, __err_state, __pos);
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, elements) => {
                            let __seq_res =
                                match __parse_BRACE_GROUP(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(__newpos, __value) => {
                                        ::peg::RuleResult::Matched(__newpos, Some(__value))
                                    }
                                    ::peg::RuleResult::Failed => {
                                        ::peg::RuleResult::Matched(__pos, None)
                                    }
                                };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, code) => {
                                    ::peg::RuleResult::Matched(
                                        __pos,
                                        (|| {
                                            if let Some(code) = code {
                                                ActionExpr(elements, Some(code)).at(sp)
                                            } else if elements.len() != 1 {
                                                ActionExpr(elements, None).at(sp)
                                            } else {
                                                elements.into_iter().next().unwrap().expr
                                            }
                                        })(),
                                    )
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_labeled<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TaggedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match {
                let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, l) => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, (|| l)())
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\":\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            } {
                ::peg::RuleResult::Matched(__newpos, __value) => {
                    ::peg::RuleResult::Matched(__newpos, Some(__value))
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, label) => {
                    let __seq_res = __parse_suffixed(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, expression) => {
                            ::peg::RuleResult::Matched(
                                __pos,
                                (|| TaggedExpr {
                                    name: label,
                                    expr: expression,
                                })(),
                            )
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_suffixed<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<SpannedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_prefixed(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, e) => {
                        let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, sp) => {
                                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "?")
                                {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| OptionalExpr(Box::new(e)).at(sp))(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"?\"");
                                        ::peg::RuleResult::Failed
                                    }
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = __parse_prefixed(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, e) => {
                                let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, sp) => {
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "**",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                let __seq_res = __parse_repeatcount(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, count) => {
                                                        let __seq_res = __parse_primary(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                sep,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| {
                                                                    Repeat {
                                                                        inner: Box::new(e),
                                                                        bound: count,
                                                                        sep: Some(Box::new(sep)),
                                                                    }
                                                                    .at(sp)
                                                                })(
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"**\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res =
                                    __parse_prefixed(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, e) => {
                                        let __seq_res =
                                            __parse_sp(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, sp) => {
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "++",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        let __seq_res = __parse_primary(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                sep,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| {
                                                                    Repeat {
                                                                        inner: Box::new(e),
                                                                        bound: BoundedRepeat::Plus,
                                                                        sep: Some(Box::new(sep)),
                                                                    }
                                                                    .at(sp)
                                                                })(
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"++\"");
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            __parse_prefixed(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, e) => {
                                                let __seq_res = __parse_sp(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "*") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_repeatcount (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , count) => { :: peg :: RuleResult :: Matched (__pos , (|| { Repeat { inner : Box :: new (e) , bound : count , sep : None } . at (sp) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"*\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = __parse_prefixed(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, e) => {
                                                        let __seq_res = __parse_sp(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "+") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { Repeat { inner : Box :: new (e) , bound : BoundedRepeat :: Plus , sep : None } . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"+\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => __parse_prefixed(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ),
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_repeatcount<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<BoundedRepeat> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<")
            {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    let __seq_res = __parse_repeatnum(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, n) => {
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ">") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(
                                        __pos,
                                        (|| BoundedRepeat::Exact(n))(),
                                    )
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\">\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"<\"");
                    ::peg::RuleResult::Failed
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = match ::peg::ParseLiteral::parse_string_literal(
                        __input, __pos, "<",
                    ) {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            let __seq_res =
                                match __parse_repeatnum(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(__newpos, __value) => {
                                        ::peg::RuleResult::Matched(__newpos, Some(__value))
                                    }
                                    ::peg::RuleResult::Failed => {
                                        ::peg::RuleResult::Matched(__pos, None)
                                    }
                                };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, min) => {
                                    match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, ",",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            let __seq_res = match __parse_repeatnum(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            ) {
                                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        Some(__value),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Matched(__pos, None)
                                                }
                                            };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, max) => {
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, ">",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| BoundedRepeat::Both(min, max))(),
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state
                                                                .mark_failure(__pos, "\">\"");
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\",\"");
                                            ::peg::RuleResult::Failed
                                        }
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"<\"");
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            ::peg::RuleResult::Matched(__pos, (|| BoundedRepeat::None)())
                        }
                    }
                }
            }
        }
    }
    fn __parse_repeatnum<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        {
            let str_start = __pos;
            match {
                let __choice_res = match __parse_INTEGER(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match __parse_BRACE_GROUP(__input, __state, __err_state, __pos) {
                            ::peg::RuleResult::Matched(pos, _) => {
                                ::peg::RuleResult::Matched(pos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_prefixed<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<SpannedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, sp) => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "$") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                let __seq_res =
                                    __parse_primary(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, expression) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| MatchStrExpr(Box::new(expression)).at(sp))(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"$\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, sp) => {
                                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&")
                                {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        let __seq_res =
                                            __parse_primary(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, expression) => {
                                                ::peg::RuleResult::Matched(
                                                    __pos,
                                                    (|| PosAssertExpr(Box::new(expression)).at(sp))(
                                                    ),
                                                )
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"&\"");
                                        ::peg::RuleResult::Failed
                                    }
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, sp) => {
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "!",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                let __seq_res = __parse_primary(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(
                                                        __pos,
                                                        expression,
                                                    ) => ::peg::RuleResult::Matched(
                                                        __pos,
                                                        (|| {
                                                            NegAssertExpr(Box::new(expression))
                                                                .at(sp)
                                                        })(
                                                        ),
                                                    ),
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"!\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    __parse_primary(__input, __state, __err_state, __pos)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_primary<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<SpannedExpr> {
        #![allow(non_snake_case, unused)]
        if let Some(entry) = __state.primary_cache.get(&__pos) {
            return entry.clone();
        }
        let __rule_result = {
            let __choice_res = {
                let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, sp) => {
                        match ::peg::ParseLiteral::parse_string_literal(
                            __input,
                            __pos,
                            "precedence",
                        ) {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "!")
                                {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "{",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value = vec![];
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __pos = if __repeat_value.is_empty() {
                                                            __pos
                                                        } else {
                                                            let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "--") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"--\"") ; :: peg :: RuleResult :: Failed } } ;
                                                            match __sep_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __newpos,
                                                                    _,
                                                                ) => __newpos,
                                                                ::peg::RuleResult::Failed => break,
                                                            }
                                                        };
                                                        let __step_res = __parse_precedence_level(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __step_res {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                __value,
                                                            ) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Matched(
                                                        __repeat_pos,
                                                        __repeat_value,
                                                    )
                                                };
                                                match __seq_res { :: peg :: RuleResult :: Matched (__pos , levels) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { PrecedenceExpr { levels : levels } . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"}\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"{\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"!\"");
                                        ::peg::RuleResult::Failed
                                    }
                                }
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"precedence\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "position") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "!") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { PositionExpr . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"!\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"position\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
                                match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "quiet") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "!") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "{") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_expression (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , e) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { QuietExpr (Box :: new (e)) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"}\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"{\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"!\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"quiet\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            __parse_sp(__input, __state, __err_state, __pos);
                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "expected") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "!") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_LITERAL (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , s) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { FailExpr (s) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"!\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"expected\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = {
                                                    __err_state.suppress_fail += 1;
                                                    let __assert_res = {
                                                        let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "_") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"_\"") ; :: peg :: RuleResult :: Failed } } ;
                                                        match __choice_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                __value,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "__") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"__\"") ; :: peg :: RuleResult :: Failed } } ;
                                                                match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "___") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"___\"") ; :: peg :: RuleResult :: Failed } } }
                                                            }
                                                        }
                                                    };
                                                    __err_state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        ::peg::RuleResult::Matched(_, __value) => {
                                                            ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_sp(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                sp,
                                                            ) => {
                                                                let __seq_res = __parse_IDENT(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        name,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            (|| {
                                                                                RuleExpr(
                                                                                    name,
                                                                                    Vec::new(),
                                                                                )
                                                                                .at(sp)
                                                                            })(
                                                                            ),
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    let __choice_res = {
                                                        let __seq_res = __parse_sp(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                sp,
                                                            ) => {
                                                                let __seq_res = __parse_IDENT(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res { :: peg :: RuleResult :: Matched (__pos , name) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! () ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty () { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , __val) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\",\"") ; :: peg :: RuleResult :: Failed } } ; match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ; let __step_res = __parse_rule_arg (__input , __state , __err_state , __pos) ; match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } } } :: peg :: RuleResult :: Matched (__repeat_pos , __repeat_value) } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , args) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { RuleExpr (name , args) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __choice_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos, __value,
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            let __choice_res = {
                                                                let __seq_res = __parse_sp(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        sp,
                                                                    ) => {
                                                                        let __seq_res =
                                                                            __parse_LITERAL(
                                                                                __input,
                                                                                __state,
                                                                                __err_state,
                                                                                __pos,
                                                                            );
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , l) => { :: peg :: RuleResult :: Matched (__pos , (|| { LiteralExpr (l) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            };
                                                            match __choice_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    __value,
                                                                ) => ::peg::RuleResult::Matched(
                                                                    __pos, __value,
                                                                ),
                                                                ::peg::RuleResult::Failed => {
                                                                    let __choice_res = {
                                                                        let __seq_res = __parse_sp(
                                                                            __input,
                                                                            __state,
                                                                            __err_state,
                                                                            __pos,
                                                                        );
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { { let __seq_res = __parse_BRACKET_GROUP (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , p) => { :: peg :: RuleResult :: Matched (__pos , (|| { PatternExpr (p) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    };
                                                                    match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_sp (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "@") { :: peg :: RuleResult :: Matched (__pos , __val) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { MarkerExpr (true) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"@\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = __parse_sp (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "@") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { MarkerExpr (false) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"@\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = __parse_sp (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , sp) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "##") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_IDENT (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , method) => { { let __seq_res = __parse_PAREN_GROUP (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , args) => { :: peg :: RuleResult :: Matched (__pos , (|| { MethodExpr (method , args . stream ()) . at (sp) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"##\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => { { let __seq_res = __parse_expression (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , expression) => { match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => { :: peg :: RuleResult :: Matched (__pos , (|| { expression }) ()) } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\")\"") ; :: peg :: RuleResult :: Failed } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "\"(\"") ; :: peg :: RuleResult :: Failed } } } } } } } } }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        __state.primary_cache.insert(__pos, __rule_result.clone());
        __rule_result
    }
    fn __parse_rule_arg<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<RuleArg> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<")
            {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    let __seq_res = __parse_expression(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, e) => {
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ">") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, (|| RuleArg::Peg(e))())
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\">\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"<\"");
                    ::peg::RuleResult::Failed
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __seq_res = {
                        let str_start = __pos;
                        match {
                            let __choice_res =
                                match __parse_LITERAL(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = match __parse_PAREN_GROUP(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => match __parse_IDENT(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        },
                                    }
                                }
                            }
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                                __newpos,
                                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                            ),
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, tt) => {
                            ::peg::RuleResult::Matched(__pos, (|| RuleArg::Rust(tt))())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
            }
        }
    }
    fn __parse_precedence_level<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<PrecedenceLevel> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_precedence_op(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                } else {
                    ::peg::RuleResult::Failed
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, operators) => ::peg::RuleResult::Matched(
                    __pos,
                    (|| PrecedenceLevel {
                        operators: operators,
                    })(),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_precedence_op<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<PrecedenceOperator> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_sp(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, span) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = __parse_labeled(__input, __state, __err_state, __pos);
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, elements) => {
                            let __seq_res =
                                __parse_BRACE_GROUP(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, action) => {
                                    ::peg::RuleResult::Matched(
                                        __pos,
                                        (|| PrecedenceOperator {
                                            span,
                                            elements,
                                            action,
                                        })(),
                                    )
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_sp<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Span> {
        #![allow(non_snake_case, unused)]
        __input.next_span(__pos)
    }
    fn __parse_KEYWORD<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res =
                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "pub") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => {
                        __err_state.mark_failure(__pos, "\"pub\"");
                        ::peg::RuleResult::Failed
                    }
                };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"crate\"");
                                ::peg::RuleResult::Failed
                            }
                        };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "rule",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"rule\"");
                                    ::peg::RuleResult::Failed
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res =
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "use",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                ::peg::RuleResult::Matched(__pos, __val)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"use\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "type",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"type\"");
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_IDENT<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Ident> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                __err_state.suppress_fail += 1;
                let __assert_res = match __parse_KEYWORD(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                __err_state.suppress_fail -= 1;
                match __assert_res {
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                    ::peg::RuleResult::Matched(..) => ::peg::RuleResult::Failed,
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = __input.ident(__pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, i) => {
                            ::peg::RuleResult::Matched(__pos, (|| i)())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_LITERAL<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Literal> {
        #![allow(non_snake_case, unused)]
        __input.literal(__pos)
    }
    fn __parse_PAREN_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Group> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Parenthesis)
    }
    fn __parse_BRACE_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Group> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Brace)
    }
    fn __parse_BRACKET_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Group> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Bracket)
    }
    fn __parse_LIFETIME<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "'") {
            ::peg::RuleResult::Matched(__pos, __val) => {
                let __seq_res = match __parse_IDENT(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => ::peg::RuleResult::Matched(__pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
            ::peg::RuleResult::Failed => {
                __err_state.mark_failure(__pos, "\"'\"");
                ::peg::RuleResult::Failed
            }
        }
    }
    fn __parse_INTEGER<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        match __parse_LITERAL(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
    }
}
