// Generated by rust-peg. Do not edit.
pub mod peg {
    #[allow(unused_imports)]
    use super::*;
    type Input = FlatTokenStream;
    type PositionRepr = <Input as ::peg::Parse>::PositionRepr;
    struct ParseState<'input> {
        _phantom: ::std::marker::PhantomData<&'input ()>,
        primary_cache: ::std::collections::HashMap<usize, ::peg::RuleResult<Expr>>,
    }
    impl<'input> ParseState<'input> {
        fn new() -> ParseState<'input> {
            ParseState {
                _phantom: ::std::marker::PhantomData,
                primary_cache: ::std::collections::HashMap::new(),
            }
        }
    }
    use crate::ast::Expr::*;
    use crate::ast::*;
    use crate::tokens::FlatTokenStream;
    use proc_macro2::{Delimiter, Ident, Literal, TokenStream};
    pub fn peg_grammar<'input>(
        __input: &'input Input,
    ) -> ::std::result::Result<Grammar, ::peg::error::ParseError<PositionRepr>> {
        #![allow(non_snake_case, unused)]
        let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
        let mut __state = ParseState::new();
        match __parse_peg_grammar(
            __input,
            &mut __state,
            &mut __err_state,
            ::peg::Parse::start(__input),
        ) {
            ::peg::RuleResult::Matched(__pos, __value) => {
                if __pos == __input.len() {
                    return Ok(__value);
                } else {
                    __err_state.mark_failure(__pos, "EOF");
                }
            }
            _ => (),
        }
        __state = ParseState::new();
        __err_state.reparse_for_error();
        match __parse_peg_grammar(
            __input,
            &mut __state,
            &mut __err_state,
            ::peg::Parse::start(__input),
        ) {
            ::peg::RuleResult::Matched(__pos, __value) => {
                if __pos == __input.len() {
                    panic!(
                        "Parser is nondeterministic: succeeded when reparsing for error position"
                    );
                } else {
                    __err_state.mark_failure(__pos, "EOF");
                }
            }
            _ => (),
        }
        Err(__err_state.into_parse_error(__input))
    }
    fn __parse_peg_grammar<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Grammar> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_rust_doc_comment(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, doc) => {
                    let __seq_res = __parse_rust_visibility(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, visibility) => {
                            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "grammar",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"grammar\"")
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res =
                                        __parse_IDENT(__input, __state, __err_state, __pos);
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, name) => {
                                            let __seq_res = __parse_grammar_args(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            );
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, args) => {
                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "for") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"for\"") } ;
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            let __seq_res = {
                                                                let str_start = __pos;
                                                                match match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , :: peg :: ParseSlice :: parse_slice (__input , str_start , __newpos)) } , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                            };
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    input_type,
                                                                ) => {
                                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "{") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"{\"") } ;
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! () ; loop { let __pos = __repeat_pos ; let __step_res = __parse_item (__input , __state , __err_state , __pos) ; match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } } } :: peg :: RuleResult :: Matched (__repeat_pos , __repeat_value) } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , items) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"}\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { Grammar { doc , visibility , name , args , input_type , items } }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_grammar_args<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<(Ident, TokenStream)>> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "(") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"(\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ",",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\",\"")
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res = {
                                let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, i) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, ":",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\":\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let str_start = __pos;
                                                    match match __parse_rust_type(
                                                        __input,
                                                        __state,
                                                        __err_state,
                                                        __pos,
                                                    ) {
                                                        ::peg::RuleResult::Matched(pos, _) => {
                                                            ::peg::RuleResult::Matched(pos, ())
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    } {
                                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                ::peg::ParseSlice::parse_slice(
                                                                    __input, str_start, __newpos,
                                                                ),
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, t) => {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| (i, t))(),
                                                        )
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, args) => {
                            let __seq_res = match match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ",",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\",\"")
                                }
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(__newpos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, ")",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\")\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, (|| args)())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_peg_rule<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Rule> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_rust_doc_comment(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, doc) => {
                    let __seq_res = __parse_cacheflag(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, cached) => {
                            let __seq_res =
                                __parse_rust_visibility(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, visibility) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "rule",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"rule\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res =
                                                __parse_IDENT(__input, __state, __err_state, __pos);
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, name) => {
                                                    let __seq_res = match __parse_rust_ty_params(
                                                        __input,
                                                        __state,
                                                        __err_state,
                                                        __pos,
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            Some(__value),
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Matched(__pos, None)
                                                        }
                                                    };
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            ty_params,
                                                        ) => {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"(\"") } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = {
                                                                        let mut __repeat_pos =
                                                                            __pos;
                                                                        let mut __repeat_value =
                                                                            vec![];
                                                                        loop {
                                                                            let __pos =
                                                                                __repeat_pos;
                                                                            let __pos =
                                                                                if __repeat_value
                                                                                    .is_empty()
                                                                                {
                                                                                    __pos
                                                                                } else {
                                                                                    let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\",\"") } ;
                                                                                    match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , }
                                                                                };
                                                                            let __step_res =
                                                                                __parse_rule_param(
                                                                                    __input,
                                                                                    __state,
                                                                                    __err_state,
                                                                                    __pos,
                                                                                );
                                                                            match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                        }
                                                                        ::peg::RuleResult::Matched(
                                                                            __repeat_pos,
                                                                            __repeat_value,
                                                                        )
                                                                    };
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , params) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\")\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "->") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"->\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , :: peg :: ParseSlice :: parse_slice (__input , str_start , __newpos)) } , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , t) => { :: peg :: RuleResult :: Matched (__pos , (|| { t }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } { :: peg :: RuleResult :: Matched (__newpos , __value) => { :: peg :: RuleResult :: Matched (__newpos , Some (__value)) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , None) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , ret_type) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "=") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"=\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = __parse_expression (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , expr) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ";") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\";\"") } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { Rule { doc , name , ty_params , params , expr , ret_type , visibility , cached } }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_cacheflag<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<bool> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"#\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"[\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "cache",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"cache\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "]",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"]\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                ::peg::RuleResult::Matched(__pos, (|| true)())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, (|| false)()),
            }
        }
    }
    fn __parse_rust_ty_params<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Vec<TokenStream>> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"<\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ",",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\",\"")
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res = {
                                let str_start = __pos;
                                match {
                                    let __choice_res =
                                        match __parse_IDENT(__input, __state, __err_state, __pos) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => match __parse_LIFETIME(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        },
                                    }
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __newpos,
                                            ::peg::ParseSlice::parse_slice(
                                                __input, str_start, __newpos,
                                            ),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                        } else {
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, p) => {
                            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ">",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\">\"")
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    ::peg::RuleResult::Matched(__pos, (|| p)())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rule_param<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<RuleParam> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, name) => {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\":\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = {
                                let __choice_res = {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "rule",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"rule\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "<",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"<\"")
                                                    }
                                                };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    let __seq_res = {
                                                        let str_start = __pos;
                                                        match match __parse_rust_type(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        } {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                _,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                ::peg::ParseSlice::parse_slice(
                                                                    __input, str_start, __newpos,
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, r) => {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ">") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\">\"") } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    (|| RuleParamTy::Rule(r))(),
                                                                ),
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                };
                                match __choice_res {
                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                        ::peg::RuleResult::Matched(__pos, __value)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        let __seq_res = {
                                            let str_start = __pos;
                                            match match __parse_rust_type(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            ) {
                                                ::peg::RuleResult::Matched(pos, _) => {
                                                    ::peg::RuleResult::Matched(pos, ())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            } {
                                                ::peg::RuleResult::Matched(__newpos, _) => {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        ::peg::ParseSlice::parse_slice(
                                                            __input, str_start, __newpos,
                                                        ),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, t) => {
                                                ::peg::RuleResult::Matched(
                                                    __pos,
                                                    (|| RuleParamTy::Rust(t))(),
                                                )
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, ty) => {
                                    ::peg::RuleResult::Matched(__pos, (|| RuleParam { name, ty })())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_item<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Item> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_rust_use(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, u) => {
                        ::peg::RuleResult::Matched(__pos, (|| Item::Use(u))())
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __seq_res = __parse_peg_rule(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, r) => {
                            ::peg::RuleResult::Matched(__pos, (|| Item::Rule(r))())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
            }
        }
    }
    fn __parse_rust_doc_comment<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Option<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match {
            let str_start = __pos;
            match {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"#\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "[",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"[\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "doc",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"doc\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "=",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"=\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = match __parse_LITERAL(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "]") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"]\"") } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            (|| {})(),
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                ::peg::RuleResult::Matched(__repeat_pos, ())
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        } {
            ::peg::RuleResult::Matched(__newpos, __value) => {
                ::peg::RuleResult::Matched(__newpos, Some(__value))
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
        }
    }
    fn __parse_rust_visibility<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Option<TokenStream>> {
        #![allow(non_snake_case, unused)]
        match {
            let str_start = __pos;
            match {
                let __choice_res = {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "pub") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"pub\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = match match __parse_PAREN_GROUP(
                                __input,
                                __state,
                                __err_state,
                                __pos,
                            ) {
                                ::peg::RuleResult::Matched(pos, _) => {
                                    ::peg::RuleResult::Matched(pos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(__newpos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    ::peg::RuleResult::Matched(__pos, (|| {})())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"crate\"")
                            }
                        }
                    }
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        } {
            ::peg::RuleResult::Matched(__newpos, __value) => {
                ::peg::RuleResult::Matched(__newpos, Some(__value))
            }
            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
        }
    }
    fn __parse_rust_use<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let str_start = __pos;
                match {
                    let __seq_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "use") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"use\""),
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res =
                                match __parse_rust_path(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = {
                                        let __choice_res = {
                                            let __seq_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "::",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"::\"")
                                                    }
                                                };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "*") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"*\"") } ;
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| {})(),
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __choice_res {
                                            ::peg::RuleResult::Matched(__pos, __value) => {
                                                ::peg::RuleResult::Matched(__pos, __value)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                let __choice_res = {
                                                    let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "::") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"::\"") } ;
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "{") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"{\"") } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = {
                                                                        let mut __repeat_pos =
                                                                            __pos;
                                                                        let mut __repeat_value =
                                                                            vec![];
                                                                        loop {
                                                                            let __pos =
                                                                                __repeat_pos;
                                                                            let __pos =
                                                                                if __repeat_value
                                                                                    .is_empty()
                                                                                {
                                                                                    __pos
                                                                                } else {
                                                                                    let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\",\"") } ;
                                                                                    match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , }
                                                                                };
                                                                            let __step_res = {
                                                                                let __seq_res = match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                                match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "as") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"as\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } , :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } , } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                            };
                                                                            match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                        }
                                                                        if __repeat_value.len() >= 1
                                                                        {
                                                                            :: peg :: RuleResult :: Matched (__repeat_pos , ())
                                                                        } else {
                                                                            :: peg :: RuleResult :: Failed
                                                                        }
                                                                    };
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"}\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __choice_res {
                                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                                        ::peg::RuleResult::Matched(__pos, __value)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        match {
                                                            let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "as") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"as\"") } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        } {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                _,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                (),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    (),
                                                                )
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, ";",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\";\"")
                                                    }
                                                };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    ::peg::RuleResult::Matched(__pos, (|| {})())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                        __newpos,
                        ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, v) => {
                    ::peg::RuleResult::Matched(__pos, (|| v.to_owned())())
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_path<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match {
                let __seq_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"crate\""),
                    };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "::") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"::\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                ::peg::RuleResult::Matched(__pos, (|| {})())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(__newpos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = {
                        let mut __repeat_pos = __pos;
                        let mut __repeat_value = vec![];
                        loop {
                            let __pos = __repeat_pos;
                            let __pos = if __repeat_value.is_empty() {
                                __pos
                            } else {
                                let __sep_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "::",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"::\"")
                                    }
                                };
                                match __sep_res {
                                    ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                                    ::peg::RuleResult::Failed => break,
                                }
                            };
                            let __step_res =
                                match __parse_IDENT(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __step_res {
                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                    __repeat_value.push(__value);
                                }
                                ::peg::RuleResult::Failed => {
                                    break;
                                }
                            }
                        }
                        if __repeat_value.len() >= 1 {
                            ::peg::RuleResult::Matched(__repeat_pos, ())
                        } else {
                            ::peg::RuleResult::Failed
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            ::peg::RuleResult::Matched(__pos, (|| {})())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_rust_type<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = match __parse_BRACKET_GROUP(__input, __state, __err_state, __pos) {
                ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"&\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res =
                                    match match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "mut",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"mut\"")
                                        }
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(__newpos, ())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = match match __parse_LIFETIME(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        } {
                                            ::peg::RuleResult::Matched(__newpos, _) => {
                                                ::peg::RuleResult::Matched(__newpos, ())
                                            }
                                            ::peg::RuleResult::Failed => {
                                                ::peg::RuleResult::Matched(__pos, ())
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, (|| {})())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "dyn",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"dyn\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = match __parse_rust_type(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                ::peg::RuleResult::Matched(__pos, (|| {})())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "impl",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"impl\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_rust_type(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, (|| {})())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = match __parse_IDENT(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "<") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"<\"") } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = {
                                                                    let mut __repeat_pos = __pos;
                                                                    let mut __repeat_value = vec![];
                                                                    loop {
                                                                        let __pos = __repeat_pos;
                                                                        let __pos =
                                                                            if __repeat_value
                                                                                .is_empty()
                                                                            {
                                                                                __pos
                                                                            } else {
                                                                                let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\",\"") } ;
                                                                                match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , }
                                                                            };
                                                                        let __step_res = {
                                                                            let __choice_res = match __parse_LIFETIME (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                            match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } }
                                                                        };
                                                                        match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                    }
                                                                    if __repeat_value.len() >= 1 {
                                                                        ::peg::RuleResult::Matched(
                                                                            __repeat_pos,
                                                                            (),
                                                                        )
                                                                    } else {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                };
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ">") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\">\"") } ;
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    let __choice_res = {
                                                        let __seq_res = match __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "::") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"::\"") } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __choice_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos, __value,
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            let __choice_res = {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"(\"") } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = {
                                                                            let mut __repeat_pos =
                                                                                __pos;
                                                                            let mut __repeat_value =
                                                                                vec![];
                                                                            loop {
                                                                                let __pos =
                                                                                    __repeat_pos;
                                                                                let __pos = if __repeat_value . is_empty () { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\",\"") } ; match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ;
                                                                                let __step_res = match __parse_rust_type (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                                match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                            }
                                                                            :: peg :: RuleResult :: Matched (__repeat_pos , ())
                                                                        };
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\")\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            };
                                                            match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match __parse_IDENT (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_expression<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        __parse_choice(__input, __state, __err_state, __pos)
    }
    fn __parse_choice<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __pos = if __repeat_value.is_empty() {
                        __pos
                    } else {
                        let __sep_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "/") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"/\"")
                                }
                            };
                        match __sep_res {
                            ::peg::RuleResult::Matched(__newpos, _) => __newpos,
                            ::peg::RuleResult::Failed => break,
                        }
                    };
                    let __step_res = __parse_sequence(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                } else {
                    ::peg::RuleResult::Failed
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, s) => ::peg::RuleResult::Matched(
                    __pos,
                    (|| {
                        if s.len() == 1 {
                            s.into_iter().next().unwrap()
                        } else {
                            ChoiceExpr(s)
                        }
                    })(),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_sequence<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_labeled(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, elements) => {
                    let __seq_res = match __parse_code_block(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            ::peg::RuleResult::Matched(__newpos, Some(__value))
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, code) => ::peg::RuleResult::Matched(
                            __pos,
                            (|| {
                                if let Some(code) = code {
                                    ActionExpr(elements, Some(code.1), code.0)
                                } else if elements.len() != 1 {
                                    ActionExpr(elements, None, false)
                                } else {
                                    elements.into_iter().next().unwrap().expr
                                }
                            })(),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_code_block<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<(bool, TokenStream)> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "{") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"{\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = match match ::peg::ParseLiteral::parse_string_literal(
                        __input, __pos, "?",
                    ) {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"?\""),
                    } {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            ::peg::RuleResult::Matched(__newpos, Some(__value))
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, is_cond) => {
                            let __seq_res = __input.group_body(__pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, code) => {
                                    let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                        __input, __pos, "}",
                                    ) {
                                        ::peg::RuleResult::Matched(__pos, __val) => {
                                            ::peg::RuleResult::Matched(__pos, __val)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "\"}\"")
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(
                                                __pos,
                                                (|| (is_cond.is_some(), code))(),
                                            )
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_labeled<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TaggedExpr> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match {
                let __seq_res = __parse_IDENT(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, l) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ":") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\":\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                ::peg::RuleResult::Matched(__pos, (|| l)())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            } {
                ::peg::RuleResult::Matched(__newpos, __value) => {
                    ::peg::RuleResult::Matched(__newpos, Some(__value))
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, label) => {
                    let __seq_res = __parse_suffixed(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, expression) => {
                            ::peg::RuleResult::Matched(
                                __pos,
                                (|| TaggedExpr {
                                    name: label,
                                    expr: expression,
                                })(),
                            )
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_suffixed<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = __parse_prefixed(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, e) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "?") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"?\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                ::peg::RuleResult::Matched(__pos, (|| OptionalExpr(Box::new(e)))())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = __parse_prefixed(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, e) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "**",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"**\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = __parse_repeatcount(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        );
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, count) => {
                                                let __seq_res = __parse_primary(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, sep) => {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| {
                                                                Repeat(
                                                                    Box::new(e),
                                                                    count,
                                                                    Some(Box::new(sep)),
                                                                )
                                                            })(
                                                            ),
                                                        )
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res =
                                    __parse_prefixed(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, e) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "++",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"++\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = __parse_primary(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, sep) => {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| {
                                                                Repeat(
                                                                    Box::new(e),
                                                                    BoundedRepeat::Plus,
                                                                    Some(Box::new(sep)),
                                                                )
                                                            })(
                                                            ),
                                                        )
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            __parse_prefixed(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, e) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "*",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"*\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_repeatcount(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                count,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| {
                                                                    Repeat(Box::new(e), count, None)
                                                                })(
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = __parse_prefixed(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, e) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "+") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"+\"") } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| {
                                                                    Repeat(
                                                                        Box::new(e),
                                                                        BoundedRepeat::Plus,
                                                                        None,
                                                                    )
                                                                })(
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => __parse_prefixed(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ),
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_repeatcount<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<BoundedRepeat> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"<\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = __parse_repeatnum(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, n) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ">",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\">\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| BoundedRepeat::Exact(n))(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"<\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res =
                                    match __parse_repeatnum(__input, __state, __err_state, __pos) {
                                        ::peg::RuleResult::Matched(__newpos, __value) => {
                                            ::peg::RuleResult::Matched(__newpos, Some(__value))
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, None)
                                        }
                                    };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, min) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, ",",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\",\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = match __parse_repeatnum(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        __value,
                                                    ) => ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        Some(__value),
                                                    ),
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Matched(__pos, None)
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, max) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ">") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\">\"") } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| BoundedRepeat::Both(min, max))(
                                                                ),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            ::peg::RuleResult::Matched(__pos, (|| BoundedRepeat::None)())
                        }
                    }
                }
            }
        }
    }
    fn __parse_repeatnum<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        {
            let str_start = __pos;
            match {
                let __choice_res = match __parse_INTEGER(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match __parse_BRACE_GROUP(__input, __state, __err_state, __pos) {
                            ::peg::RuleResult::Matched(pos, _) => {
                                ::peg::RuleResult::Matched(pos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            } {
                ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                    __newpos,
                    ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_prefixed<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "$")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"$\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = __parse_primary(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, expression) => {
                                ::peg::RuleResult::Matched(
                                    __pos,
                                    (|| MatchStrExpr(Box::new(expression)))(),
                                )
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "&") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"&\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res =
                                    __parse_primary(__input, __state, __err_state, __pos);
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, expression) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| PosAssertExpr(Box::new(expression)))(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "!",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"!\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            __parse_primary(__input, __state, __err_state, __pos);
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, expression) => {
                                                ::peg::RuleResult::Matched(
                                                    __pos,
                                                    (|| NegAssertExpr(Box::new(expression)))(),
                                                )
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    __parse_primary(__input, __state, __err_state, __pos)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_primary<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Expr> {
        #![allow(non_snake_case, unused)]
        if let Some(entry) = __state.primary_cache.get(&__pos) {
            return entry.clone();
        }
        let __rule_result = {
            let __choice_res = {
                let __seq_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "precedence") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"precedence\"")
                        }
                    };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "!") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"!\"")
                                }
                            };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "{",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"{\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = vec![];
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __pos = if __repeat_value.is_empty() {
                                                    __pos
                                                } else {
                                                    let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "--") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"--\"") } ;
                                                    match __sep_res {
                                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                                            __newpos
                                                        }
                                                        ::peg::RuleResult::Failed => break,
                                                    }
                                                };
                                                let __step_res = __parse_precedence_level(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                );
                                                match __step_res {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        __value,
                                                    ) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, levels) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "}",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"}\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| PrecedenceExpr { levels: levels })(
                                                            ),
                                                        )
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res = {
                        let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                            __input, __pos, "position",
                        ) {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"position\"")
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "!",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"!\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "(",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"(\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, ")",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\")\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| PositionExpr)(),
                                                        )
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "quiet",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"quiet\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "!",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"!\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "{",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"{\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_expression(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                e,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "}") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"}\"") } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            (|| {
                                                                                QuietExpr(Box::new(
                                                                                    e,
                                                                                ))
                                                                            })(
                                                                            ),
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = {
                                        let __seq_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "expected",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"expected\"")
                                                }
                                            };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "!",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state.mark_failure(__pos, "\"!\"")
                                                        }
                                                    };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"(\"") } ;
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = __parse_LITERAL(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        s,
                                                                    ) => {
                                                                        let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\")\"") } ;
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { FailExpr (s) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            let __choice_res = {
                                                let __seq_res = {
                                                    __err_state.suppress_fail += 1;
                                                    let __assert_res = {
                                                        let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "_") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"_\"") } ;
                                                        match __choice_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                __value,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "__") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"__\"") } ;
                                                                match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "___") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"___\"") } }
                                                            }
                                                        }
                                                    };
                                                    __err_state.suppress_fail -= 1;
                                                    match __assert_res {
                                                        ::peg::RuleResult::Matched(_, __value) => {
                                                            ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        let __seq_res = __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                name,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| RuleExpr(name, Vec::new()))(),
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    let __choice_res = {
                                                        let __seq_res = __parse_IDENT(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                name,
                                                            ) => {
                                                                let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"(\"") } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        let __seq_res = {
                                                                            let mut __repeat_pos =
                                                                                __pos;
                                                                            let mut __repeat_value =
                                                                                vec![];
                                                                            loop {
                                                                                let __pos =
                                                                                    __repeat_pos;
                                                                                let __pos = if __repeat_value . is_empty () { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ",") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\",\"") } ; match __sep_res { :: peg :: RuleResult :: Matched (__newpos , _) => { __newpos } , :: peg :: RuleResult :: Failed => break , } } ;
                                                                                let __step_res = __parse_rule_arg (__input , __state , __err_state , __pos) ;
                                                                                match __step_res { :: peg :: RuleResult :: Matched (__newpos , __value) => { __repeat_pos = __newpos ; __repeat_value . push (__value) ; } , :: peg :: RuleResult :: Failed => { break ; } }
                                                                            }
                                                                            :: peg :: RuleResult :: Matched (__repeat_pos , __repeat_value)
                                                                        };
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , args) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\")\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { RuleExpr (name , args) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    };
                                                    match __choice_res {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __value,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos, __value,
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            let __choice_res = {
                                                                let __seq_res = __parse_LITERAL(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                );
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        l,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            (|| LiteralExpr(l))(),
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            };
                                                            match __choice_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    __value,
                                                                ) => ::peg::RuleResult::Matched(
                                                                    __pos, __value,
                                                                ),
                                                                ::peg::RuleResult::Failed => {
                                                                    let __choice_res = {
                                                                        let __seq_res =
                                                                            __parse_BRACKET_GROUP(
                                                                                __input,
                                                                                __state,
                                                                                __err_state,
                                                                                __pos,
                                                                            );
                                                                        match __seq_res { :: peg :: RuleResult :: Matched (__pos , p) => { :: peg :: RuleResult :: Matched (__pos , (|| { PatternExpr (p) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                    };
                                                                    match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"(\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "@") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"@\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\")\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { MarkerExpr (true) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "@") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"@\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { MarkerExpr (false) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "##") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"##\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = __parse_IDENT (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , method) => { { let __seq_res = __parse_PAREN_GROUP (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , args) => { :: peg :: RuleResult :: Matched (__pos , (|| { MethodExpr (method , args) }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } ; match __choice_res { :: peg :: RuleResult :: Matched (__pos , __value) => :: peg :: RuleResult :: Matched (__pos , __value) , :: peg :: RuleResult :: Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , "(") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\"(\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { { let __seq_res = __parse_expression (__input , __state , __err_state , __pos) ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , expression) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal (__input , __pos , ")") { :: peg :: RuleResult :: Matched (__pos , __val) => :: peg :: RuleResult :: Matched (__pos , __val) , :: peg :: RuleResult :: Failed => __err_state . mark_failure (__pos , "\")\"") } ; match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , (|| { expression }) ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } } } } } } } } }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        __state.primary_cache.insert(__pos, __rule_result.clone());
        __rule_result
    }
    fn __parse_rule_arg<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<RuleArg> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res = {
                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "<")
                {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"<\""),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = __parse_expression(__input, __state, __err_state, __pos);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, e) => {
                                let __seq_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, ">",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\">\"")
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(__pos, (|| RuleArg::Peg(e))())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __seq_res = {
                        let str_start = __pos;
                        match {
                            let __choice_res =
                                match __parse_LITERAL(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res = match __parse_PAREN_GROUP(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => match __parse_IDENT(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        ) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        },
                                    }
                                }
                            }
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                                __newpos,
                                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                            ),
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, tt) => {
                            ::peg::RuleResult::Matched(__pos, (|| RuleArg::Rust(tt))())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
            }
        }
    }
    fn __parse_precedence_level<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<PrecedenceLevel> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_precedence_op(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 1 {
                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                } else {
                    ::peg::RuleResult::Failed
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, operators) => ::peg::RuleResult::Matched(
                    __pos,
                    (|| PrecedenceLevel {
                        operators: operators,
                    })(),
                ),
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_precedence_op<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<PrecedenceOperator> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = __parse_labeled(__input, __state, __err_state, __pos);
                    match __step_res {
                        ::peg::RuleResult::Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        ::peg::RuleResult::Failed => {
                            break;
                        }
                    }
                }
                ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, elements) => {
                    let __seq_res = __parse_BRACE_GROUP(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, action) => ::peg::RuleResult::Matched(
                            __pos,
                            (|| PrecedenceOperator { elements, action })(),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_KEYWORD<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __choice_res =
                match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "pub") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        ::peg::RuleResult::Matched(__pos, __val)
                    }
                    ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"pub\""),
                };
            match __choice_res {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    ::peg::RuleResult::Matched(__pos, __value)
                }
                ::peg::RuleResult::Failed => {
                    let __choice_res =
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "crate") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"crate\"")
                            }
                        };
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res = match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, "rule",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, __val)
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"rule\"")
                                }
                            };
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res =
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "use",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                ::peg::RuleResult::Matched(__pos, __val)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"use\"")
                                            }
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "type",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"type\"")
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    fn __parse_IDENT<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Ident> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = {
                __err_state.suppress_fail += 1;
                let __assert_res = match __parse_KEYWORD(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                __err_state.suppress_fail -= 1;
                match __assert_res {
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                    ::peg::RuleResult::Matched(..) => ::peg::RuleResult::Failed,
                }
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = __input.ident(__pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, i) => {
                            ::peg::RuleResult::Matched(__pos, (|| i)())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_LITERAL<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<Literal> {
        #![allow(non_snake_case, unused)]
        __input.literal(__pos)
    }
    fn __parse_PAREN_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Parenthesis)
    }
    fn __parse_BRACE_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Brace)
    }
    fn __parse_BRACKET_GROUP<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<TokenStream> {
        #![allow(non_snake_case, unused)]
        __input.group(__pos, Delimiter::Bracket)
    }
    fn __parse_LIFETIME<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        {
            let __seq_res = match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "'") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    ::peg::RuleResult::Matched(__pos, __val)
                }
                ::peg::RuleResult::Failed => __err_state.mark_failure(__pos, "\"'\""),
            };
            match __seq_res {
                ::peg::RuleResult::Matched(__pos, _) => {
                    let __seq_res = match __parse_IDENT(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            ::peg::RuleResult::Matched(__pos, (|| {})())
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
            }
        }
    }
    fn __parse_INTEGER<'input>(
        __input: &'input Input,
        __state: &mut ParseState<'input>,
        __err_state: &mut ::peg::error::ErrorState,
        __pos: usize,
    ) -> ::peg::RuleResult<()> {
        #![allow(non_snake_case, unused)]
        match __parse_LITERAL(__input, __state, __err_state, __pos) {
            ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
        }
    }
}
