// Generated by rust-peg. Do not edit.
use self :: RuleResult :: { Matched , Failed } ; use translate ::*; use std :: char ; use codemap :: { self , Spanned } ; fn escape_default ( s : & str ) -> String { s . chars ( ) . flat_map ( | c | c . escape_default ( ) ) . collect ( ) } fn char_range_at ( s : & str , pos : usize ) -> ( char , usize ) { let c = & s [ pos .. ] . chars ( ) . next ( ) . unwrap ( ) ; let next_pos = pos + c . len_utf8 ( ) ; ( * c , next_pos ) } # [ derive ( Clone ) ] enum RuleResult < T > { Matched ( usize , T ) , Failed , } # [ derive ( PartialEq , Eq , Debug , Clone ) ] pub struct ParseError { pub line : usize , pub column : usize , pub offset : usize , pub expected : :: std :: collections :: HashSet < & 'static str > , } pub type ParseResult < T > = Result < T , ParseError > ; impl :: std :: fmt :: Display for ParseError { fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: result :: Result < ( ) , :: std :: fmt :: Error > { write ! ( fmt , "error at {}:{}: expected " , self . line , self . column ) ? ; if self . expected . is_empty ( ) { write ! ( fmt , "EOF" ) ? ; } else if self . expected . len ( ) == 1 { write ! ( fmt , "`{}`" , escape_default ( self . expected . iter ( ) . next ( ) . unwrap ( ) ) ) ? ; } else { let mut iter = self . expected . iter ( ) ; write ! ( fmt , "one of `{}`" , escape_default ( iter . next ( ) . unwrap ( ) ) ) ? ; for elem in iter { write ! ( fmt , ", `{}`" , escape_default ( elem ) ) ? ; } } Ok ( ( ) ) } } impl :: std :: error :: Error for ParseError { fn description ( & self ) -> & str { "parse error" } } fn slice_eq ( input : & str , state : & mut ParseState , pos : usize , m : & 'static str ) -> RuleResult < ( ) > { # ! [ inline ( always ) ] # ! [ allow ( dead_code ) ] let l = m . len ( ) ; if input . len ( ) >= pos + l && & input . as_bytes ( ) [ pos .. pos + l ] == m . as_bytes ( ) { Matched ( pos + l , ( ) ) } else { state . mark_failure ( pos , m ) } } fn any_char ( input : & str , state : & mut ParseState , pos : usize ) -> RuleResult < ( ) > { # ! [ inline ] # ! [ allow ( dead_code ) ] if input . len ( ) > pos { let ( _ , next ) = char_range_at ( input , pos ) ; Matched ( next , ( ) ) } else { state . mark_failure ( pos , "<character>" ) } } fn pos_to_line ( input : & str , pos : usize ) -> ( usize , usize ) { let before = & input [ .. pos ] ; let line = before . as_bytes ( ) . iter ( ) . filter ( | && c | c == b'\n' ) . count ( ) + 1 ; let col = before . chars ( ) . rev ( ) . take_while ( | & c | c != '\n' ) . count ( ) + 1 ; ( line , col ) } impl < 'input > ParseState < 'input > { # [ inline ( never ) ] fn mark_failure_slow_path ( & mut self , pos : usize , expected : & 'static str ) { if pos == self . max_err_pos { self . expected . insert ( expected ) ; } } # [ inline ( always ) ] fn mark_failure ( & mut self , pos : usize , expected : & 'static str ) -> RuleResult < ( ) > { if self . suppress_fail == 0 { if self . reparsing_on_error { self . mark_failure_slow_path ( pos , expected ) ; } else if pos > self . max_err_pos { self . max_err_pos = pos ; } } Failed } } struct ParseState < 'input > { max_err_pos : usize , suppress_fail : usize , reparsing_on_error : bool , expected : :: std :: collections :: HashSet < & 'static str > , _phantom : :: std :: marker :: PhantomData < & 'input ( ) > , primary_cache : :: std :: collections :: HashMap < usize , RuleResult < Spanned < Expr > >> } impl < 'input > ParseState < 'input > { fn new ( ) -> ParseState < 'input > { ParseState { max_err_pos : 0 , suppress_fail : 0 , reparsing_on_error : false , expected : :: std :: collections :: HashSet :: new ( ) , _phantom : :: std :: marker :: PhantomData , primary_cache : :: std :: collections :: HashMap :: new ( ) } } } fn __parse_items < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Vec < Spanned < Item >> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = __parse_item ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , items ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { items } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_peg_rule < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Rule > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_cacheflag ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , cached ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_visibility ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , visibility ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = __parse_RULE ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_returntype ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , ret_type ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "=" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expr ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ";" ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Rule { name , expr , ret_type , visibility , cached } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_rust_visibility < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Option < String > > { # ! [ allow ( non_snake_case , unused ) ] match { let __seq_res = { let str_start = __pos ; match { let __choice_res = { let __seq_res = __parse_PUB ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { ')' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\')\'" ) , } } else { __state . mark_failure ( __pos , "\')\'" ) } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ")" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_CRATE ( __input , __state , __pos , file_span ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { s . to_owned ( ) } ) } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } } fn __parse_cacheflag < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < bool > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#[cache]" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { true } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { false } ) } } } fn __parse_template < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Template > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , list ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "," ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { list } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , params ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "=" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ";" ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Template { name : name , params : params , expr : Box :: new ( expression ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_item < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Item > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_rust_use ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , u ) => { Matched ( __pos , { Item :: Use ( u ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_peg_rule ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , r ) => { Matched ( __pos , { Item :: Rule ( r ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_template ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , { Item :: Template ( t ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_grammar_args ( __input , __state , __pos , file_span ) } } } } } } } fn __parse_grammar_args < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Item > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "#![" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "arguments" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_grammar_argument ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , list ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "," ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { list } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ")" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "]" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Item :: GrammarArgs ( args ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_grammar_argument < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( String , String ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ":" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , { ( i , t ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_type_string < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match __parse_rust_type ( __input , __state , __pos , file_span ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , tp ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { tp . to_owned ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_returntype < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "->" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , tp ) => { Matched ( __pos , { tp } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { "()" . to_string ( ) } ) } } } fn __parse_rust_identifier < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { __state . suppress_fail += 1 ; let res = { let __seq_res = __parse_idStart ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = __parse_idContinue ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } ; __state . suppress_fail -= 1 ; res } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { __state . mark_failure ( __pos , "identifier" ) ; Failed } } } } fn __parse_rust_use < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_USE ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_path ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match { let __seq_res = slice_eq ( __input , __state , __pos , "as" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match { let __seq_res = slice_eq ( __input , __state , __pos , "as" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_identifier ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } } } } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ";" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , v ) => { Matched ( __pos , { v . to_owned ( ) } ) } Failed => Failed , } } } fn __parse_rust_path < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_rust_identifier ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } fn __parse_rust_type < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "[" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_type ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "]" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "&" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = slice_eq ( __input , __state , __pos , "mut" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = slice_eq ( __input , __state , __pos , "\'" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "dyn" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "impl" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "\'" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_identifier ( __input , __state , __pos , file_span ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_rust_type ( __input , __state , __pos , file_span ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ">" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_rust_type ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ")" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_rust_identifier ( __input , __state , __pos , file_span ) } } } } } } } } } } } } } } } fn __parse_expression < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] __parse_choice ( __input , __state , __pos , file_span ) } fn __parse_choice < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __seq_res = __parse_sequence ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , head ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "/" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_sequence ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { s } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , tail ) => { Matched ( __pos , { if tail . is_empty ( ) { head . node } else { let mut list = tail ; list . insert ( 0 , head ) ; ChoiceExpr ( list ) } } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_sequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_labeled ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_action ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , code ) => { Matched ( __pos , { ActionExpr ( elements , code . 0 , code . 1 ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_prefixed ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { Matched ( __pos , { if elements . len ( ) != 1 { SequenceExpr ( elements ) } else { elements . into_iter ( ) . next ( ) . unwrap ( ) . node } } ) } Failed => Failed , } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_labeled < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < TaggedExpr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match { let __seq_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , l ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ":" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { l } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , label ) => { { let __seq_res = __parse_prefixed ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { TaggedExpr { name : label , expr : Box :: new ( expression ) } } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_prefixed < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "$" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { MatchStrExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "&" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { PosAssertExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "!" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { NegAssertExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_suffixed ( __input , __state , __pos , file_span ) } } } fn __parse_suffixed < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "?" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { OptionalExpr ( Box :: new ( e ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "**" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , count ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , count , Some ( Box :: new ( sep ) ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "++" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , BoundedRepeat :: Plus , Some ( Box :: new ( sep ) ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , count ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , count , None ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = __parse_primary ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "+" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , BoundedRepeat :: Plus , None ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_primary ( __input , __state , __pos , file_span ) } } } fn __parse_repeatcount < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < BoundedRepeat > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatnum ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , n ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { BoundedRepeat :: Exact ( n ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __pos , file_span ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , min ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __pos , file_span ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , max ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { BoundedRepeat :: Both ( min , max ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { BoundedRepeat :: None } ) } } } } } fn __parse_repeatnum < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_integer ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , i ) => { Matched ( __pos , { i . to_string ( ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { e } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } fn __parse_primary < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] if let Some ( entry ) = __state . primary_cache . get ( & __pos ) { return entry . clone ( ) ; } let __rule_result = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __choice_res = slice_eq ( __input , __state , __pos , "<" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "->" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "=" ) } } } } } Failed => Failed , } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { RuleExpr ( name ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_expression ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , list ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "," ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { list } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "=" ) } Failed => Failed , } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { TemplateInvoke ( name , args ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_literal ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_class ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "." ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { AnyCharExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "@" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { MarkerExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#position" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { PositionExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#quiet" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { QuietExpr ( Box :: new ( e ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#expected" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_doubleQuotedString ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ")" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { FailExpr ( s ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#infix" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , atom ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_infix_level ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , levels ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixExpr { atom : Box :: new ( atom ) , levels : levels } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , ")" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { expression . node } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } } } } } } } } } } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; __state . primary_cache . insert ( __pos , __rule_result . clone ( ) ) ; __rule_result } fn __parse_infix_level < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < InfixLevel > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#L" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixAssoc :: Left } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "#R" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixAssoc :: Right } ) } Failed => Failed , } } } } ; match __seq_res { Matched ( __pos , assoc ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = __parse_infix_op ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , operators ) => { Matched ( __pos , { InfixLevel { assoc : assoc , operators : operators } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_infix_op < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < InfixOperator > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_labeled ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , action ) => { { let __seq_res = __parse__ ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixOperator { elements , action } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_rust_expr < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_braced ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_nonBraceCharacters ( __input , __state , __pos , file_span ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , literal ) => { Matched ( __pos , { format ! ( "{{ {} }}" , literal ) } ) } Failed => Failed , } } } fn __parse_action < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( String , bool ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match slice_eq ( __input , __state , __pos , "?" ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , cond ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , literal ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { ( literal , cond . is_some ( ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_braced < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_braced ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_nonBraceCharacters ( __input , __state , __pos , file_span ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "}" ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_nonBraceCharacters < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '{' | '}' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\'{\' | \'}\' " ) , } } else { __state . mark_failure ( __pos , "\'{\' | \'}\' " ) } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } fn __parse_USE < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "use" ) ; match __seq_res { Matched ( __pos , _ ) => { { __state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_PUB < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "pub" ) ; match __seq_res { Matched ( __pos , _ ) => { { __state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_CRATE < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "crate" ) ; match __seq_res { Matched ( __pos , _ ) => { { __state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_RULE < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "rule" ) ; match __seq_res { Matched ( __pos , _ ) => { { __state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_keyword < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_USE ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_PUB ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_CRATE ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_RULE ( __input , __state , __pos , file_span ) } } } } } } } fn __parse_integer < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < usize > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ..='9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\'0\'..=\'9\'" ) , } } else { __state . mark_failure ( __pos , "\'0\'..=\'9\'" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , i ) => { Matched ( __pos , { i . parse ( ) . unwrap ( ) } ) } Failed => Failed , } } } fn __parse_idStart < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ..='z' | 'A' ..='Z' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'_\'" ) , } } else { __state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'_\'" ) } } fn __parse_idContinue < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ..='z' | 'A' ..='Z' | '0' ..='9' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'0\'..=\'9\' | \'_\'" ) , } } else { __state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'0\'..=\'9\' | \'_\'" ) } } fn __parse_identifier < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { __state . suppress_fail += 1 ; let res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_keyword ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_idStart ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = __parse_idContinue ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , chars ) => { Matched ( __pos , { chars . to_owned ( ) } ) } Failed => Failed , } } } Failed => Failed , } } ; __state . suppress_fail -= 1 ; res } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { __state . mark_failure ( __pos , "identifier" ) ; Failed } } } } fn __parse_literal < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = __parse_doubleQuotedString ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_singleQuotedString ( __input , __state , __pos , file_span ) } } ; match __seq_res { Matched ( __pos , value ) => { Matched ( __pos , { LiteralExpr ( value ) } ) } Failed => Failed , } } } fn __parse_string < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = __parse_doubleQuotedString ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_singleQuotedString ( __input , __state , __pos , file_span ) } } ; match __seq_res { Matched ( __pos , string ) => { Matched ( __pos , { string } ) } Failed => Failed , } } } fn __parse_doubleQuotedString < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\"" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_doubleQuotedCharacter ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "\"" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { s . into_iter ( ) . collect ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_doubleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleDoubleQuotedCharacter ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __pos , file_span ) } } } } } } } } } } } fn __parse_simpleDoubleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = slice_eq ( __input , __state , __pos , "\"" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos , file_span ) } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { c . chars ( ) . next ( ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_singleQuotedString < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\'" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_singleQuotedCharacter ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "\'" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { s . into_iter ( ) . collect ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_singleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleSingleQuotedCharacter ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __pos , file_span ) } } } } } } } } } } } fn __parse_simpleSingleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = slice_eq ( __input , __state , __pos , "\'" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos , file_span ) } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { c . chars ( ) . next ( ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_class < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "[" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = slice_eq ( __input , __state , __pos , "]" ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , pattern ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "]" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { PatternExpr ( pattern . to_owned ( ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_simpleEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = __parse_digit ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "x" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "u" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos , file_span ) } } } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { match c . chars ( ) . next ( ) . unwrap ( ) { 'n' => '\n' , 'r' => '\r' , 't' => '\t' , x => x } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_zeroEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\0" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_digit ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 0u8 as char } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_hex2EscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\x" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_hexDigit ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_hexDigit ( __input , __state , __pos , file_span ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , value ) => { Matched ( __pos , { char :: from_u32 ( u32 :: from_str_radix ( value , 16 ) . unwrap ( ) ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_unicodeEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\u{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_hexDigit ( __input , __state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , value ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { char :: from_u32 ( u32 :: from_str_radix ( value , 16 ) . unwrap ( ) ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_eolEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_eol ( __input , __state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { '\n' } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_digit < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ..='9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\'0\'..=\'9\'" ) , } } else { __state . mark_failure ( __pos , "\'0\'..=\'9\'" ) } } fn __parse_hexDigit < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ..='9' | 'a' ..='f' | 'A' ..='F' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , " \'0\'..=\'9\' | \'a\'..=\'f\' | \'A\'..=\'F\' " ) , } } else { __state . mark_failure ( __pos , " \'0\'..=\'9\' | \'a\'..=\'f\' | \'A\'..=\'F\' " ) } } fn __parse__ < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { __state . suppress_fail += 1 ; let res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_whitespace ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_eol ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_comment ( __input , __state , __pos , file_span ) } } } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; __state . suppress_fail -= 1 ; res } } fn __parse_comment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_singleLineComment ( __input , __state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_multiLineComment ( __input , __state , __pos , file_span ) } } } fn __parse_singleLineComment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "//" ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_eolChar ( __input , __state , __pos , file_span ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } } fn __parse_multiLineComment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "/*" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = slice_eq ( __input , __state , __pos , "*/" ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "*/" ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_eol < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = slice_eq ( __input , __state , __pos , "\n" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\r\n" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\r" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\u{2028}" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "\u{2029}" ) } } } } } } } } } fn __parse_eolChar < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '\n' | '\r' | '\u{2028}' | '\u{2029}' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\'\\n\' | \'\\r\' | \'\\u{2028}\' | \'\\u{2029}\'" ) , } } else { __state . mark_failure ( __pos , "\'\\n\' | \'\\r\' | \'\\u{2028}\' | \'\\u{2029}\'" ) } } fn __parse_whitespace < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize , file_span : codemap :: Span ) -> RuleResult < ( ) > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { ' ' | '\t' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "\' \' | \'\\t\'" ) , } } else { __state . mark_failure ( __pos , "\' \' | \'\\t\'" ) } } pub fn items < 'input > ( __input : & 'input str , file_span : codemap :: Span ) -> ParseResult < Vec < Spanned < Item >> > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_items ( __input , & mut __state , 0 , file_span ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => ( ) } let __err_pos = __state . max_err_pos ; __state = ParseState :: new ( ) ; __state . reparsing_on_error = true ; __state . max_err_pos = __err_pos ; __parse_items ( __input , & mut __state , 0 , file_span ) ; let ( __line , __col ) = pos_to_line ( __input , __err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __err_pos , expected : __state . expected , } ) }