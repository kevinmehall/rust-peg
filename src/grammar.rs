// Generated by rust-peg. Do not edit.
use self :: RuleResult :: { Matched , Failed } ; use translate::*; use std::char; fn escape_default ( s : & str ) -> String {
s . chars (  ) . flat_map ( | c | c . escape_default (  ) ) . collect (  ) }
fn char_range_at ( s : & str , pos : usize ) -> ( char , usize ) {
let c = & s [ pos .. ] . chars (  ) . next (  ) . unwrap (  ) ; let next_pos =
pos + c . len_utf8 (  ) ; ( * c , next_pos ) } # [ derive ( Clone ) ] enum
RuleResult < T > { Matched ( usize , T ) , Failed , } # [
derive ( PartialEq , Eq , Debug , Clone ) ] pub struct ParseError {
pub line : usize , pub column : usize , pub offset : usize , pub expected : ::
std :: collections :: HashSet < & 'static str > , } pub type ParseResult < T >
= Result < T , ParseError > ; impl :: std :: fmt :: Display for ParseError {
fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: result
:: Result < (  ) , :: std :: fmt :: Error > {
try ! (
write ! ( fmt , "error at {}:{}: expected " , self . line , self . column ) )
; if self . expected . len (  ) == 0 { try ! ( write ! ( fmt , "EOF" ) ) ; }
else if self . expected . len (  ) == 1 {
try ! (
write ! (
fmt , "`{}`" , escape_default (
self . expected . iter (  ) . next (  ) . unwrap (  ) ) ) ) ; } else {
let mut iter = self . expected . iter (  ) ; try ! (
write ! (
fmt , "one of `{}`" , escape_default ( iter . next (  ) . unwrap (  ) ) ) ) ;
for elem in iter {
try ! ( write ! ( fmt , ", `{}`" , escape_default ( elem ) ) ) ; } } Ok ( (  )
) } } impl :: std :: error :: Error for ParseError {
fn description ( & self ) -> & str { "parse error" } } fn slice_eq (
input : & str , state : & mut ParseState , pos : usize , m : & 'static str )
-> RuleResult < (  ) > {
# ! [ inline ] # ! [ allow ( dead_code ) ] let l = m . len (  ) ; if input .
len (  ) >= pos + l && & input . as_bytes (  ) [ pos .. pos + l ] == m .
as_bytes (  ) { Matched ( pos + l , (  ) ) } else {
state . mark_failure ( pos , m ) } } fn slice_eq_case_insensitive (
input : & str , state : & mut ParseState , pos : usize , m : & 'static str )
-> RuleResult < (  ) > {
# ! [ inline ] # ! [ allow ( dead_code ) ] let mut used = 0usize ; let mut
input_iter = input [ pos .. ] . chars (  ) . flat_map (
| x | x . to_uppercase (  ) ) ; for m_char_upper in m . chars (  ) . flat_map
( | x | x . to_uppercase (  ) ) {
used += m_char_upper . len_utf8 (  ) ; let input_char_result = input_iter .
next (  ) ; if input_char_result . is_none (  ) || input_char_result . unwrap
(  ) != m_char_upper { return state . mark_failure ( pos , m ) ; } } Matched (
pos + used , (  ) ) } fn any_char (
input : & str , state : & mut ParseState , pos : usize ) -> RuleResult < (  )
> {
# ! [ inline ] # ! [ allow ( dead_code ) ] if input . len (  ) > pos {
let ( _ , next ) = char_range_at ( input , pos ) ; Matched ( next , (  ) ) }
else { state . mark_failure ( pos , "<character>" ) } } fn pos_to_line (
input : & str , pos : usize ) -> ( usize , usize ) {
let before = & input [ .. pos ] ; let line = before . as_bytes (  ) . iter (
) . filter ( | && c | c == b'\n' ) . count (  ) + 1 ; let col = before . chars
(  ) . rev (  ) . take_while ( | & c | c != '\n' ) . count (  ) + 1 ; (
line , col ) } impl < 'input > ParseState < 'input > {
fn mark_failure ( & mut self , pos : usize , expected : & 'static str ) ->
RuleResult < (  ) > {
if self . suppress_fail == 0 {
if pos > self . max_err_pos {
self . max_err_pos = pos ; self . expected . clear (  ) ; } if pos == self .
max_err_pos { self . expected . insert ( expected ) ; } } Failed } } struct ParseState < 'input > { max_err_pos : usize , suppress_fail : usize , expected : :: std :: collections :: HashSet < & 'static str > , _phantom : :: std :: marker :: PhantomData < & 'input ( ) > , primary_cache : :: std :: collections :: HashMap < usize , RuleResult < Expr >> } impl < 'input > ParseState < 'input > { fn new ( ) -> ParseState < 'input > { ParseState { max_err_pos : 0 , suppress_fail : 0 , expected : :: std :: collections :: HashSet :: new ( ) , _phantom : :: std :: marker :: PhantomData , primary_cache : :: std :: collections :: HashMap :: new ( ) } } } 

 fn __parse_items < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Vec<Item> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_item ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , items ) => { Matched ( __pos , {  items  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_rule < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Rule > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_exportflag ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , legacy_exported ) => { { let __seq_res = __parse_cacheflag ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , cached ) => { { let __seq_res = __parse_pubflag ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , public ) => { { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse_returntype ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , returns ) => { { let __seq_res = __parse_equals ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = match __parse_semicolon ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      Rule{
        name: name,
        expr: Box::new(expression),
        ret_type: returns,
        exported: public || legacy_exported,
        cached: cached
      }
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_pubflag < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < bool > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_PUB ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  true  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  false  } ) } Failed => Failed , } } } } } 

 fn __parse_exportflag < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < bool > { # ! [ allow ( non_snake_case , unused ) ] { __state . suppress_fail += 1 ; let res = { let __choice_res = { let __seq_res = { let __choice_res = slice_eq ( __input , __state , __pos , "#[export]" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "#[pub]" ) } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { true } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { false } ) } Failed => Failed , } } } } ; __state . suppress_fail -= 1 ; res } } 

 fn __parse_cacheflag < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < bool > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#[cache]" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { true } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { false } ) } } } 

 fn __parse_template < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Template > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse_lt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = __parse_comma ( __input , __state , __pos ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = __parse_identifier ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , params ) => { { let __seq_res = __parse_gt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_equals ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = match __parse_semicolon ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
    Template { name: name, params: params, expr: Box::new(expression) }
   } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_item < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Item > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_rust_use ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , u ) => { Matched ( __pos , {  Item::Use(u)  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rule ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , r ) => { Matched ( __pos , {  Item::Rule(r)  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_template ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , {  Item::Template(t)  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_grammar_args ( __input , __state , __pos ) } } } } } } } 

 fn __parse_grammar_args < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Item > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "#![" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "arguments" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lparen ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = __parse_comma ( __input , __state , __pos ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = __parse_grammar_argument ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = __parse_rparen ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "]" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  Item::GrammarArgs(args)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_grammar_argument < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < (String, String) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = __parse_colon ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , {  (i, t)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_type_string < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match __parse_rust_type ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , tp ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  tp.to_owned()  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_returntype < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_returns ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , tp ) => { Matched ( __pos , {  tp  } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , {  "()".to_string()  } ) } } } 

 fn __parse_rust_identifier < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { __state . suppress_fail += 1 ; let res = { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z_]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z_]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '0' ... '9' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } ; __state . suppress_fail -= 1 ; res } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { __state . mark_failure ( __pos , "identifier" ) ; Failed } } } } 

 fn __parse_rust_use < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_USE ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_path ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { match { let __seq_res = slice_eq ( __input , __state , __pos , "as" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match { let __seq_res = slice_eq ( __input , __state , __pos , "as" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_identifier ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } } } } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ";" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , v ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  v.to_owned()  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_rust_path < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = __parse_rust_identifier ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } 

 fn __parse_rust_type < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "[" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_type ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "]" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "&" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = slice_eq ( __input , __state , __pos , "mut" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = slice_eq ( __input , __state , __pos , "'" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "'" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_identifier ( __input , __state , __pos ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_rust_type ( __input , __state , __pos ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ">" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "::" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = __parse_rust_type ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , ")" ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_rust_identifier ( __input , __state , __pos ) } } } } } } } } } } } 

 fn __parse_expression < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] __parse_choice ( __input , __state , __pos ) } 

 fn __parse_choice < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_sequence ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , head ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = __parse_slash ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_sequence ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { s } ) } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , tail ) => { Matched ( __pos , { 
      if tail.len() > 0 {
        let mut list = tail;
        list.insert(0, head);
        ChoiceExpr(list)
      } else {
        head
      }
     } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_sequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_labeled ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = __parse_action ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , code ) => { Matched ( __pos , { 
      ActionExpr(elements, code.0, code.1)
     } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_prefixed ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { Matched ( __pos , { 
      if elements.len() != 1 {
          SequenceExpr(elements)
      } else {
          elements.into_iter().next().unwrap()
      }
     } ) } Failed => Failed , } } } } } 

 fn __parse_labeled < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < TaggedExpr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , label ) => { { let __seq_res = __parse_colon ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_prefixed ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { 
      TaggedExpr{ name: Some(label), expr: Box::new(expression) }
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = __parse_prefixed ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expr ) => { Matched ( __pos , { 
      TaggedExpr{ name: None, expr: Box::new(expr) }
   } ) } Failed => Failed , } } } } } 

 fn __parse_prefixed < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_dollar ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { 
      MatchStrExpr(Box::new(expression))
     } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_and ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { 
      PosAssertExpr(Box::new(expression))
     } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_not ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { 
      NegAssertExpr(Box::new(expression))
     } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_suffixed ( __input , __state , __pos ) } } } } } } } 

 fn __parse_suffixed < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_question ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
       OptionalExpr(Box::new(e))
     } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_starstar ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , count ) => { { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { 
      Repeat(Box::new(e), count, Some(Box::new(sep)))
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_plusplus ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { 
      Repeat(Box::new(e), BoundedRepeat::Plus, Some(Box::new(sep)))
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_star ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , count ) => { Matched ( __pos , { 
      Repeat(Box::new(e), count, None)
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_plus ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      Repeat(Box::new(e), BoundedRepeat::Plus, None)
     } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_primary ( __input , __state , __pos ) } } } } } } } } } } } 

 fn __parse_repeatcount < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < BoundedRepeat > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_lt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatnum ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , n ) => { { let __seq_res = __parse_gt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  BoundedRepeat::Exact(n)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_lt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __pos ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , min ) => { { let __seq_res = __parse_comma ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __pos ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , max ) => { { let __seq_res = __parse_gt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  BoundedRepeat::Both(min, max)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  BoundedRepeat::None  } ) } Failed => Failed , } } } } } } } 

 fn __parse_repeatnum < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_integer ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  i.to_string()  } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = __parse_lbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_rbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { e } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } 

 fn __parse_primary < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] if let Some ( entry ) = __state . primary_cache . get ( & __pos ) { return entry . clone ( ) ; } let __rule_result = { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_lt ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_returns ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_equals ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      RuleExpr(name)
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse_lt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . len ( ) > 0 { let __sep_res = __parse_comma ( __input , __state , __pos ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } else { __pos } ; let __step_res = __parse_expression ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = __parse_gt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_equals ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      TemplateInvoke(name, args)
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_literal ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_class ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_dot ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  AnyCharExpr  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#=" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , runtime_match ) => { { let __seq_res = __parse_rbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  RuntimeMatchExpr(runtime_match)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , runtime ) => { { let __seq_res = __parse_rbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  RuntimeExpr(runtime)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#position" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  PositionExpr  } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#quiet" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_gt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  QuietExpr(Box::new(e))  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#expected" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lparen ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_doubleQuotedString ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = __parse_rparen ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  FailExpr(s)  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#infix" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , atom ) => { { let __seq_res = __parse_gt ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_lbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_infix_level ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , levels ) => { { let __seq_res = __parse_rbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  InfixExpr{ atom: Box::new(atom), levels:levels } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = __parse_lparen ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = __parse_rparen ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  expression  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } } } } } } } } } } } } } } } ; __state . primary_cache . insert ( __pos , __rule_result . clone ( ) ) ; __rule_result } 

 fn __parse_infix_level < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < InfixLevel > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = { let __seq_res = slice_eq ( __input , __state , __pos , "#L" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  InfixAssoc::Left  } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "#R" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  InfixAssoc::Right } ) } Failed => Failed , } } } } ; match __seq_res { Matched ( __pos , assoc ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_infix_op ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , operators ) => { Matched ( __pos , {  InfixLevel{ assoc: assoc, operators: operators}  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_infix_op < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < InfixOperator > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , l ) => { { let __seq_res = match { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , var ) => { { let __seq_res = __parse_colon ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { var } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , op ) => { { let __seq_res = __parse_primary ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse_identifier ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , r ) => { { let __seq_res = __parse_lbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , action ) => { { let __seq_res = __parse_rbrace ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  InfixOperator{ operator:Box::new(e), action: action, l_arg:l, op_arg:op, r_arg:r }  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_rust_expr < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_braced ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_nonBraceCharacters ( __input , __state , __pos ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , literal ) => { Matched ( __pos , {  format!("{{ {} }}", literal)  } ) } Failed => Failed , } } } 

 fn __parse_action < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < (String, /*is conditional match?*/ bool) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match slice_eq ( __input , __state , __pos , "?" ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , cond ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , literal ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
     (literal, cond.is_some())
   } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_braced < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_braced ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_nonBraceCharacters ( __input , __state , __pos ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "}" ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_nonBraceCharacters < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '{' | '}' => __state . mark_failure ( __pos , "[^{}]" ) , _ => Matched ( __next , ( ) ) , } } else { __state . mark_failure ( __pos , "[^{}]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } 

 fn __parse_equals < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "=" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_colon < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , ":" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_semicolon < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , ";" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_slash < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "/" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_and < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "&" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_not < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "!" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_dollar < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "$" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_question < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "?" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_star < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "*" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_starstar < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "**" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_plus < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "+" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_plusplus < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "++" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_lparen < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "(" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_rparen < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , ")" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_dot < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "." ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_returns < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "->" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_lbrace < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "{" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_rbrace < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_comma < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "," ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_lt < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "<" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_gt < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , ">" ) ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } 

 fn __parse_USE < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "use" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '0' ... '9' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_PUB < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "pub" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '0' ... '9' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { __parse___ ( __input , __state , __pos ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_keyword < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_USE ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_PUB ( __input , __state , __pos ) } } } 

 fn __parse_integer < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < usize > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  i.parse().unwrap()  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_identifier < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { __state . suppress_fail += 1 ; let res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_keyword ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z_]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z_]" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { 'a' ... 'z' | 'A' ... 'Z' | '0' ... '9' | '_' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) , } } else { __state . mark_failure ( __pos , "[a-zA-Z0-9_]" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , chars ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  chars.to_owned()  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; __state . suppress_fail -= 1 ; res } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { __state . mark_failure ( __pos , "identifier" ) ; Failed } } } } 

 fn __parse_literal < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = __parse_doubleQuotedString ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_singleQuotedString ( __input , __state , __pos ) } } ; match __seq_res { Matched ( __pos , value ) => { { let __seq_res = match slice_eq ( __input , __state , __pos , "i" ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , case_insensitive ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      LiteralExpr(value,case_insensitive.is_some())
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_string < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = __parse_doubleQuotedString ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_singleQuotedString ( __input , __state , __pos ) } } ; match __seq_res { Matched ( __pos , string ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  string  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_doubleQuotedString < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\"" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_doubleQuotedCharacter ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "\"" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  s.into_iter().collect()  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_doubleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleDoubleQuotedCharacter ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __pos ) } } } } } } } } } } } 

 fn __parse_simpleDoubleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = slice_eq ( __input , __state , __pos , "\"" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos ) } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , {  c.chars().next().unwrap()  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_singleQuotedString < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "'" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_singleQuotedCharacter ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "'" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  s.into_iter().collect()  } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_singleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleSingleQuotedCharacter ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __pos ) } } } } } } } } } } } 

 fn __parse_simpleSingleQuotedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = slice_eq ( __input , __state , __pos , "'" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos ) } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , {  c.chars().next().unwrap()  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_class < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "[" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match slice_eq ( __input , __state , __pos , "^" ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , inverted ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_classCharacterRange ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_classCharacter ( __input , __state , __pos ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , parts ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "]" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match slice_eq ( __input , __state , __pos , "i" ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , flags ) => { { let __seq_res = __parse___ ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      CharSetExpr(inverted.is_some(), parts)
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_classCharacterRange < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < CharSetCase > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_bracketDelimitedCharacter ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , begin ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "-" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_bracketDelimitedCharacter ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { 
      //TODO: check start > end
      CharSetCase{start:begin, end:end}
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_classCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < CharSetCase > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_bracketDelimitedCharacter ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , char_ ) => { Matched ( __pos , { 
      CharSetCase{start:char_, end:char_}
     } ) } Failed => Failed , } } } 

 fn __parse_bracketDelimitedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleBracketDelimitedCharacter ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __pos ) } } } } } } } } } } } 

 fn __parse_simpleBracketDelimitedCharacter < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = slice_eq ( __input , __state , __pos , "]" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos ) } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , {  c.chars().next().unwrap()  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_simpleEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = { let __choice_res = __parse_digit ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "x" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "u" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __pos ) } } } } } } ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match any_char ( __input , __state , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { 
      match c.chars().next().unwrap() {
        //'b' => '\b',
        //'f' => '\f',
        'n' => '\n',
        'r' => '\r',
        't' => '\t',
        //'v' => '\v',
         x  => x
      }
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_zeroEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\0" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_digit ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  0u8 as char  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_hex2EscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\x" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_hexDigit ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_hexDigit ( __input , __state , __pos ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , value ) => { Matched ( __pos , { 
      char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
     } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_unicodeEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\u{" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_hexDigit ( __input , __state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , value ) => { { let __seq_res = slice_eq ( __input , __state , __pos , "}" ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 
      char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
     } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_eolEscapeSequence < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "\\" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_eol ( __input , __state , __pos ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , {  '\n'  } ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_digit < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9]" ) , } } else { __state . mark_failure ( __pos , "[0-9]" ) } } 

 fn __parse_hexDigit < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '0' ... '9' | 'a' ... 'f' | 'A' ... 'F' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[0-9a-fA-F]" ) , } } else { __state . mark_failure ( __pos , "[0-9a-fA-F]" ) } } 

 fn __parse___ < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { __state . suppress_fail += 1 ; let res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_whitespace ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_eol ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_comment ( __input , __state , __pos ) } } } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; __state . suppress_fail -= 1 ; res } } 

 fn __parse_comment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_singleLineComment ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_multiLineComment ( __input , __state , __pos ) } } } 

 fn __parse_singleLineComment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "//" ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = __parse_eolChar ( __input , __state , __pos ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } } 

 fn __parse_multiLineComment < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = slice_eq ( __input , __state , __pos , "/*" ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __state . suppress_fail += 1 ; let __assert_res = slice_eq ( __input , __state , __pos , "*/" ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { any_char ( __input , __state , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { slice_eq ( __input , __state , __pos , "*/" ) } Failed => Failed , } } } Failed => Failed , } } } 

 fn __parse_eol < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = slice_eq ( __input , __state , __pos , "\n" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\r\n" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\r" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = slice_eq ( __input , __state , __pos , "\u{2028}" ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => slice_eq ( __input , __state , __pos , "\u{2029}" ) } } } } } } } } } 

 fn __parse_eolChar < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { '\n' | '\r' | '\u{2028}' | '\u{2029}' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[\n\r\u{2028}\u{2029}]" ) , } } else { __state . mark_failure ( __pos , "[\n\r\u{2028}\u{2029}]" ) } } 

 fn __parse_whitespace < 'input > ( __input : & 'input str , __state : & mut ParseState < 'input > , __pos : usize ) -> RuleResult < () > { # ! [ allow ( non_snake_case , unused ) ] if __input . len ( ) > __pos { let ( __ch , __next ) = char_range_at ( __input , __pos ) ; match __ch { ' ' | '\t' | '\u{a0}' | '\u{feff}' | '\u{1680}' | '\u{180e}' | '\u{2000}' ... '\u{200a}' | '\u{202f}' | '\u{205f}' | '\u{3000}' => Matched ( __next , ( ) ) , _ => __state . mark_failure ( __pos , "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]" ) , } } else { __state . mark_failure ( __pos , "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]" ) } } 

 pub fn items < 'input > ( __input : & 'input str ) -> ParseResult < Vec<Item> > { # ! [ allow ( non_snake_case , unused ) ] let mut __state = ParseState :: new ( ) ; match __parse_items ( __input , & mut __state , 0 ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => { } } let ( __line , __col ) = pos_to_line ( __input , __state . max_err_pos ) ; Err ( ParseError { line : __line , column : __col , offset : __state . max_err_pos , expected : __state . expected , } ) }