// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use translate::*;
use std::char;
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
    primary_cache: ::std::collections::HashMap<usize, RuleResult<Expr>>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),
                   _phantom: ::std::marker::PhantomData,
                   primary_cache: ::std::collections::HashMap::new(),}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_grammar<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Grammar> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_rust_use(input, state, pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, imports) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_rule(input, state,
                                                               pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, rules) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            Grammar{imports:
                                                                        imports,
                                                                    rules:
                                                                        rules,}
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rule<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<Rule> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_exportflag(input, state, pos);
            match seq_res {
                Matched(pos, exported) => {
                    {
                        let seq_res = parse_cacheflag(input, state, pos);
                        match seq_res {
                            Matched(pos, cached) => {
                                {
                                    let seq_res =
                                        parse_identifier(input, state, pos);
                                    match seq_res {
                                        Matched(pos, name) => {
                                            {
                                                let seq_res =
                                                    parse_returntype(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, returns) => {
                                                        {
                                                            let seq_res =
                                                                parse_equals(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_expression(input,
                                                                                             state,
                                                                                             pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    expression)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        match parse_semicolon(input,
                                                                                                              state,
                                                                                                              pos)
                                                                                            {
                                                                                            Matched(newpos,
                                                                                                    value)
                                                                                            =>
                                                                                            {
                                                                                                Matched(newpos,
                                                                                                        Some(value))
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            {
                                                                                                Matched(pos,
                                                                                                        None)
                                                                                            }
                                                                                        };
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            Rule{name:
                                                                                                                     name,
                                                                                                                 expr:
                                                                                                                     Box::new(expression),
                                                                                                                 ret_type:
                                                                                                                     returns,
                                                                                                                 exported:
                                                                                                                     exported,
                                                                                                                 cached:
                                                                                                                     cached,}
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_exportflag<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<bool> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "#[export]");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed =>
                                slice_eq(input, state, pos, "#[pub]"),
                            }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse___(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { true })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos, { false })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_cacheflag<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<bool> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "#[cache]");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse___(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { true })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let match_str = &input[start_pos..pos];
                    Matched(pos, { false })
                }
            }
        }
    }
}
fn parse_returntype<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<String> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_returns(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_rust_type(input, state,
                                                                pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    match_str.trim().to_string()
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, tp) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos, { tp })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let match_str = &input[start_pos..pos];
                    Matched(pos, { "()".to_string() })
                }
            }
        }
    }
}
fn parse_rust_use<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<RustUse> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "use");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_rust_path(input, state, pos);
                                    match seq_res {
                                        Matched(pos, p) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let choice_res =
                                                                        {
                                                                            let start_pos =
                                                                                pos;
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             "::");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse___(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            slice_eq(input,
                                                                                                                     state,
                                                                                                                     pos,
                                                                                                                     "*");
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        parse___(input,
                                                                                                                                 state,
                                                                                                                                 pos);
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                _)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    &input[start_pos..pos];
                                                                                                                                Matched(pos,
                                                                                                                                        {
                                                                                                                                            RustUseGlob(p.clone())
                                                                                                                                        })
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        };
                                                                    match choice_res
                                                                        {
                                                                        Matched(pos,
                                                                                value)
                                                                        =>
                                                                        Matched(pos,
                                                                                value),
                                                                        Failed
                                                                        => {
                                                                            let choice_res =
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "::");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse___(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    slice_eq(input,
                                                                                                                             state,
                                                                                                                             pos,
                                                                                                                             "{");
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Matched(pos,
                                                                                                                            _)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse___(input,
                                                                                                                                         state,
                                                                                                                                         pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        _)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let seq_res =
                                                                                                                                            {
                                                                                                                                                let mut repeat_pos =
                                                                                                                                                    pos;
                                                                                                                                                let mut repeat_value =
                                                                                                                                                    vec!();
                                                                                                                                                loop 
                                                                                                                                                     {
                                                                                                                                                    let pos =
                                                                                                                                                        repeat_pos;
                                                                                                                                                    let pos =
                                                                                                                                                        if repeat_value.len()
                                                                                                                                                               >
                                                                                                                                                               0
                                                                                                                                                           {
                                                                                                                                                            let sep_res =
                                                                                                                                                                {
                                                                                                                                                                    let seq_res =
                                                                                                                                                                        slice_eq(input,
                                                                                                                                                                                 state,
                                                                                                                                                                                 pos,
                                                                                                                                                                                 ",");
                                                                                                                                                                    match seq_res
                                                                                                                                                                        {
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                _)
                                                                                                                                                                        =>
                                                                                                                                                                        {
                                                                                                                                                                            parse___(input,
                                                                                                                                                                                     state,
                                                                                                                                                                                     pos)
                                                                                                                                                                        }
                                                                                                                                                                        Failed
                                                                                                                                                                        =>
                                                                                                                                                                        Failed,
                                                                                                                                                                    }
                                                                                                                                                                };
                                                                                                                                                            match sep_res
                                                                                                                                                                {
                                                                                                                                                                Matched(newpos,
                                                                                                                                                                        _)
                                                                                                                                                                =>
                                                                                                                                                                {
                                                                                                                                                                    newpos
                                                                                                                                                                }
                                                                                                                                                                Failed
                                                                                                                                                                =>
                                                                                                                                                                break
                                                                                                                                                                    ,
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            pos
                                                                                                                                                        };
                                                                                                                                                    let step_res =
                                                                                                                                                        parse_identifier(input,
                                                                                                                                                                         state,
                                                                                                                                                                         pos);
                                                                                                                                                    match step_res
                                                                                                                                                        {
                                                                                                                                                        Matched(newpos,
                                                                                                                                                                value)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            repeat_pos
                                                                                                                                                                =
                                                                                                                                                                newpos;
                                                                                                                                                            repeat_value.push(value);
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            break
                                                                                                                                                                ;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                if repeat_value.len()
                                                                                                                                                       >=
                                                                                                                                                       1usize
                                                                                                                                                   {
                                                                                                                                                    Matched(repeat_pos,
                                                                                                                                                            repeat_value)
                                                                                                                                                } else {
                                                                                                                                                    Failed
                                                                                                                                                }
                                                                                                                                            };
                                                                                                                                        match seq_res
                                                                                                                                            {
                                                                                                                                            Matched(pos,
                                                                                                                                                    names)
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                {
                                                                                                                                                    let seq_res =
                                                                                                                                                        slice_eq(input,
                                                                                                                                                                 state,
                                                                                                                                                                 pos,
                                                                                                                                                                 "}");
                                                                                                                                                    match seq_res
                                                                                                                                                        {
                                                                                                                                                        Matched(pos,
                                                                                                                                                                _)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            {
                                                                                                                                                                let seq_res =
                                                                                                                                                                    parse___(input,
                                                                                                                                                                             state,
                                                                                                                                                                             pos);
                                                                                                                                                                match seq_res
                                                                                                                                                                    {
                                                                                                                                                                    Matched(pos,
                                                                                                                                                                            _)
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        {
                                                                                                                                                                            let match_str =
                                                                                                                                                                                &input[start_pos..pos];
                                                                                                                                                                            Matched(pos,
                                                                                                                                                                                    {
                                                                                                                                                                                        RustUseList(p.clone(),
                                                                                                                                                                                                    names)
                                                                                                                                                                                    })
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                    Failed
                                                                                                                                                                    =>
                                                                                                                                                                    Failed,
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        Failed,
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            Failed
                                                                                                                                            =>
                                                                                                                                            Failed,
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                Failed,
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed
                                                                                                                    =>
                                                                                                                    Failed,
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                };
                                                                            match choice_res
                                                                                {
                                                                                Matched(pos,
                                                                                        value)
                                                                                =>
                                                                                Matched(pos,
                                                                                        value),
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let match_str =
                                                                                                        &input[start_pos..pos];
                                                                                                    Matched(pos,
                                                                                                            {
                                                                                                                RustUseSimple(p.clone())
                                                                                                            })
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        v) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            slice_eq(input,
                                                                                     state,
                                                                                     pos,
                                                                                     ";");
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            v
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rust_path<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let pos =
                            if repeat_value.len() > 0 {
                                let sep_res =
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, "::");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse___(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match sep_res {
                                    Matched(newpos, _) => { newpos }
                                    Failed => break ,
                                }
                            } else { pos };
                        let step_res = parse_identifier(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1usize {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rust_type<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<()> {
    {
        let choice_res =
            {
                let seq_res = slice_eq(input, state, pos, "()");
                match seq_res {
                    Matched(pos, _) => { parse___(input, state, pos) }
                    Failed => Failed,
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let seq_res = slice_eq(input, state, pos, "[");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_rust_type(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "]");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        parse___(input, state,
                                                                 pos)
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "&");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                match {
                                                          let seq_res =
                                                              slice_eq(input,
                                                                       state,
                                                                       pos,
                                                                       "\'");
                                                          match seq_res {
                                                              Matched(pos, _)
                                                              => {
                                                                  parse_identifier(input,
                                                                                   state,
                                                                                   pos)
                                                              }
                                                              Failed =>
                                                              Failed,
                                                          }
                                                      } {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    parse_rust_type(input,
                                                                    state,
                                                                    pos)
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let seq_res =
                                            parse_identifier(input, state,
                                                             pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        slice_eq(input, state,
                                                                 pos, "<");
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    {
                                                                        let mut repeat_pos =
                                                                            pos;
                                                                        let mut repeat_value =
                                                                            vec!();
                                                                        loop 
                                                                             {
                                                                            let pos =
                                                                                repeat_pos;
                                                                            let pos =
                                                                                if repeat_value.len()
                                                                                       >
                                                                                       0
                                                                                   {
                                                                                    let sep_res =
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse___(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            slice_eq(input,
                                                                                                                     state,
                                                                                                                     pos,
                                                                                                                     ",");
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                parse___(input,
                                                                                                                         state,
                                                                                                                         pos)
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        };
                                                                                    match sep_res
                                                                                        {
                                                                                        Matched(newpos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            newpos
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        break
                                                                                            ,
                                                                                    }
                                                                                } else {
                                                                                    pos
                                                                                };
                                                                            let step_res =
                                                                                {
                                                                                    let choice_res =
                                                                                        {
                                                                                            let seq_res =
                                                                                                slice_eq(input,
                                                                                                         state,
                                                                                                         pos,
                                                                                                         "\'");
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_identifier(input,
                                                                                                                             state,
                                                                                                                             pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         "")
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        };
                                                                                    match choice_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                value)
                                                                                        =>
                                                                                        Matched(pos,
                                                                                                value),
                                                                                        Failed
                                                                                        =>
                                                                                        parse_rust_type(input,
                                                                                                        state,
                                                                                                        pos),
                                                                                    }
                                                                                };
                                                                            match step_res
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    repeat_pos
                                                                                        =
                                                                                        newpos;
                                                                                    repeat_value.push(value);
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    break
                                                                                        ;
                                                                                }
                                                                            }
                                                                        }
                                                                        Matched(repeat_pos,
                                                                                ())
                                                                    };
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         ">");
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        _)
                                                                                =>
                                                                                {
                                                                                    parse___(input,
                                                                                             state,
                                                                                             pos)
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            {
                                                let seq_res =
                                                    parse_identifier(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "::");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_rust_type(input,
                                                                                    state,
                                                                                    pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "(");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        {
                                                                            let mut repeat_pos =
                                                                                pos;
                                                                            let mut repeat_value =
                                                                                vec!();
                                                                            loop 
                                                                                 {
                                                                                let pos =
                                                                                    repeat_pos;
                                                                                let pos =
                                                                                    if repeat_value.len()
                                                                                           >
                                                                                           0
                                                                                       {
                                                                                        let sep_res =
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse___(input,
                                                                                                             state,
                                                                                                             pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         ",");
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    parse___(input,
                                                                                                                             state,
                                                                                                                             pos)
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            };
                                                                                        match sep_res
                                                                                            {
                                                                                            Matched(newpos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                newpos
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            break
                                                                                                ,
                                                                                        }
                                                                                    } else {
                                                                                        pos
                                                                                    };
                                                                                let step_res =
                                                                                    parse_rust_type(input,
                                                                                                    state,
                                                                                                    pos);
                                                                                match step_res
                                                                                    {
                                                                                    Matched(newpos,
                                                                                            value)
                                                                                    =>
                                                                                    {
                                                                                        repeat_pos
                                                                                            =
                                                                                            newpos;
                                                                                        repeat_value.push(value);
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    {
                                                                                        break
                                                                                            ;
                                                                                    }
                                                                                }
                                                                            }
                                                                            if repeat_value.len()
                                                                                   >=
                                                                                   1usize
                                                                               {
                                                                                Matched(repeat_pos,
                                                                                        ())
                                                                            } else {
                                                                                Failed
                                                                            }
                                                                        };
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             ")");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos)
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let seq_res =
                                                            parse_identifier(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "")
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_expression<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Expr> {
    parse_choice(input, state, pos)
}
fn parse_choice<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_sequence(input, state, pos);
            match seq_res {
                Matched(pos, head) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse_slash(input, state,
                                                                pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_sequence(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        s) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    s
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, tail) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                if tail.len() > 0 {
                                                    let mut list = tail;
                                                    list.insert(0, head);
                                                    ChoiceExpr(list)
                                                } else { head }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_sequence<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_labeled(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, elements) => {
                            {
                                let seq_res = parse_action(input, state, pos);
                                match seq_res {
                                    Matched(pos, code) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        ActionExpr(elements,
                                                                   code.0,
                                                                   code.1)
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_prefixed(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, elements) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        {
                                            if elements.len() != 1 {
                                                SequenceExpr(elements)
                                            } else {
                                                elements.into_iter().next().unwrap()
                                            }
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_labeled<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<TaggedExpr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, label) => {
                            {
                                let seq_res = parse_colon(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_prefixed(input, state,
                                                               pos);
                                            match seq_res {
                                                Matched(pos, expression) => {
                                                    {
                                                        let match_str =
                                                            &input[start_pos..pos];
                                                        Matched(pos,
                                                                {
                                                                    TaggedExpr{name:
                                                                                   Some(label),
                                                                               expr:
                                                                                   Box::new(expression),}
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_prefixed(input, state, pos);
                    match seq_res {
                        Matched(pos, expr) => {
                            {
                                let match_str = &input[start_pos..pos];
                                Matched(pos,
                                        {
                                            TaggedExpr{name: None,
                                                       expr: Box::new(expr),}
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_prefixed<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_dollar(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_suffixed(input, state, pos);
                                match seq_res {
                                    Matched(pos, expression) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        MatchStrExpr(Box::new(expression))
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_and(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_suffixed(input, state, pos);
                                        match seq_res {
                                            Matched(pos, expression) => {
                                                {
                                                    let match_str =
                                                        &input[start_pos..pos];
                                                    Matched(pos,
                                                            {
                                                                PosAssertExpr(Box::new(expression))
                                                            })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_not(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_suffixed(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, expression)
                                                    => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        NegAssertExpr(Box::new(expression))
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => parse_suffixed(input, state, pos),
                        }
                    }
                }
            }
        }
    }
}
fn parse_suffixed<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            state.primary_cache.get(&pos).map(|entry|
                                                                  entry.clone()).unwrap_or_else(||
                                                                                                    parse_primary(input,
                                                                                                                  state,
                                                                                                                  pos))
                        };
                    match seq_res {
                        Matched(pos, expression) => {
                            {
                                let seq_res =
                                    parse_question(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                &input[start_pos..pos];
                                            Matched(pos,
                                                    {
                                                        OptionalExpr(Box::new(expression))
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res =
                                {
                                    state.primary_cache.get(&pos).map(|entry|
                                                                          entry.clone()).unwrap_or_else(||
                                                                                                            parse_primary(input,
                                                                                                                          state,
                                                                                                                          pos))
                                };
                            match seq_res {
                                Matched(pos, expression) => {
                                    {
                                        let seq_res =
                                            parse_starstar(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        {
                                                            state.primary_cache.get(&pos).map(|entry|
                                                                                                  entry.clone()).unwrap_or_else(||
                                                                                                                                    parse_primary(input,
                                                                                                                                                  state,
                                                                                                                                                  pos))
                                                        };
                                                    match seq_res {
                                                        Matched(pos, sep) => {
                                                            {
                                                                let match_str =
                                                                    &input[start_pos..pos];
                                                                Matched(pos,
                                                                        {
                                                                            Repeat(Box::new(expression),
                                                                                   0,
                                                                                   None,
                                                                                   Some(Box::new(sep)))
                                                                        })
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        {
                                            state.primary_cache.get(&pos).map(|entry|
                                                                                  entry.clone()).unwrap_or_else(||
                                                                                                                    parse_primary(input,
                                                                                                                                  state,
                                                                                                                                  pos))
                                        };
                                    match seq_res {
                                        Matched(pos, expression) => {
                                            {
                                                let seq_res =
                                                    parse_plusplus(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    state.primary_cache.get(&pos).map(|entry|
                                                                                                          entry.clone()).unwrap_or_else(||
                                                                                                                                            parse_primary(input,
                                                                                                                                                          state,
                                                                                                                                                          pos))
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        sep)
                                                                => {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    Repeat(Box::new(expression),
                                                                                           1,
                                                                                           None,
                                                                                           Some(Box::new(sep)))
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                {
                                                    state.primary_cache.get(&pos).map(|entry|
                                                                                          entry.clone()).unwrap_or_else(||
                                                                                                                            parse_primary(input,
                                                                                                                                          state,
                                                                                                                                          pos))
                                                };
                                            match seq_res {
                                                Matched(pos, expression) => {
                                                    {
                                                        let seq_res =
                                                            parse_star(input,
                                                                       state,
                                                                       pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        &input[start_pos..pos];
                                                                    Matched(pos,
                                                                            {
                                                                                Repeat(Box::new(expression),
                                                                                       0,
                                                                                       None,
                                                                                       None)
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            {
                                                let start_pos = pos;
                                                {
                                                    let seq_res =
                                                        {
                                                            state.primary_cache.get(&pos).map(|entry|
                                                                                                  entry.clone()).unwrap_or_else(||
                                                                                                                                    parse_primary(input,
                                                                                                                                                  state,
                                                                                                                                                  pos))
                                                        };
                                                    match seq_res {
                                                        Matched(pos,
                                                                expression) =>
                                                        {
                                                            {
                                                                let seq_res =
                                                                    parse_plus(input,
                                                                               state,
                                                                               pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                &input[start_pos..pos];
                                                                            Matched(pos,
                                                                                    {
                                                                                        Repeat(Box::new(expression),
                                                                                               1,
                                                                                               None,
                                                                                               None)
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    {
                                                        let start_pos = pos;
                                                        {
                                                            let seq_res =
                                                                {
                                                                    state.primary_cache.get(&pos).map(|entry|
                                                                                                          entry.clone()).unwrap_or_else(||
                                                                                                                                            parse_primary(input,
                                                                                                                                                          state,
                                                                                                                                                          pos))
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        expression)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_lbrace(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_integer(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                n)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_rbrace(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let match_str =
                                                                                                                &input[start_pos..pos];
                                                                                                            Matched(pos,
                                                                                                                    {
                                                                                                                        Repeat(Box::new(expression),
                                                                                                                               n,
                                                                                                                               Some(n),
                                                                                                                               None)
                                                                                                                    })
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            {
                                                                let start_pos =
                                                                    pos;
                                                                {
                                                                    let seq_res =
                                                                        {
                                                                            state.primary_cache.get(&pos).map(|entry|
                                                                                                                  entry.clone()).unwrap_or_else(||
                                                                                                                                                    parse_primary(input,
                                                                                                                                                                  state,
                                                                                                                                                                  pos))
                                                                        };
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                expression)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_lbrace(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse_integer(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        min)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_comma(input,
                                                                                                                        state,
                                                                                                                        pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        match parse_integer(input,
                                                                                                                                            state,
                                                                                                                                            pos)
                                                                                                                            {
                                                                                                                            Matched(newpos,
                                                                                                                                    value)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                Matched(newpos,
                                                                                                                                        Some(value))
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                Matched(pos,
                                                                                                                                        None)
                                                                                                                            }
                                                                                                                        };
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                max)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let seq_res =
                                                                                                                                    parse_rbrace(input,
                                                                                                                                                 state,
                                                                                                                                                 pos);
                                                                                                                                match seq_res
                                                                                                                                    {
                                                                                                                                    Matched(pos,
                                                                                                                                            _)
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        {
                                                                                                                                            let match_str =
                                                                                                                                                &input[start_pos..pos];
                                                                                                                                            Matched(pos,
                                                                                                                                                    {
                                                                                                                                                        Repeat(Box::new(expression),
                                                                                                                                                               min,
                                                                                                                                                               max,
                                                                                                                                                               None)
                                                                                                                                                    })
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    Failed
                                                                                                                                    =>
                                                                                                                                    Failed,
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            };
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    {
                                                                        let start_pos =
                                                                            pos;
                                                                        {
                                                                            let seq_res =
                                                                                {
                                                                                    state.primary_cache.get(&pos).map(|entry|
                                                                                                                          entry.clone()).unwrap_or_else(||
                                                                                                                                                            parse_primary(input,
                                                                                                                                                                          state,
                                                                                                                                                                          pos))
                                                                                };
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        expression)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        let seq_res =
                                                                                            parse_lbrace(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse_comma(input,
                                                                                                                    state,
                                                                                                                    pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    match parse_integer(input,
                                                                                                                                        state,
                                                                                                                                        pos)
                                                                                                                        {
                                                                                                                        Matched(newpos,
                                                                                                                                value)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Matched(newpos,
                                                                                                                                    Some(value))
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Matched(pos,
                                                                                                                                    None)
                                                                                                                        }
                                                                                                                    };
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Matched(pos,
                                                                                                                            max)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse_rbrace(input,
                                                                                                                                             state,
                                                                                                                                             pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        _)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let match_str =
                                                                                                                                            &input[start_pos..pos];
                                                                                                                                        Matched(pos,
                                                                                                                                                {
                                                                                                                                                    Repeat(Box::new(expression),
                                                                                                                                                           0,
                                                                                                                                                           max,
                                                                                                                                                           None)
                                                                                                                                                })
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                Failed,
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed
                                                                                                                    =>
                                                                                                                    Failed,
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    };
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    {
                                                                        state.primary_cache.get(&pos).map(|entry|
                                                                                                              entry.clone()).unwrap_or_else(||
                                                                                                                                                parse_primary(input,
                                                                                                                                                              state,
                                                                                                                                                              pos))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_primary<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Expr> {
    let rule_result =
        {
            let choice_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res = parse_identifier(input, state, pos);
                        match seq_res {
                            Matched(pos, name) => {
                                {
                                    let seq_res =
                                        {
                                            let assert_res =
                                                {
                                                    let seq_res =
                                                        match parse_string(input,
                                                                           state,
                                                                           pos)
                                                            {
                                                            Matched(newpos,
                                                                    value) =>
                                                            {
                                                                Matched(newpos,
                                                                        Some(value))
                                                            }
                                                            Failed => {
                                                                Matched(pos,
                                                                        None)
                                                            }
                                                        };
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    parse_returntype(input,
                                                                                     state,
                                                                                     pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        parse_equals(input,
                                                                                     state,
                                                                                     pos)
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                            match assert_res {
                                                Failed => Matched(pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        { RuleExpr(name) })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match choice_res {
                Matched(pos, value) => Matched(pos, value),
                Failed => {
                    let choice_res = parse_literal(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_class(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse_dot(input, state,
                                                              pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        AnyCharExpr
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed => {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse_lparen(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_expression(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        expression)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_rparen(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                expression
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    state.primary_cache.insert(pos, rule_result.clone());
    rule_result
}
fn parse_action<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<(String, bool)> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "{");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "?") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, cond) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            {
                                                                let seq_res =
                                                                    parse_braced(input,
                                                                                 state,
                                                                                 pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        slice_eq(input,
                                                                                 state,
                                                                                 pos,
                                                                                 "")
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            };
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_nonBraceCharacters(input,
                                                                                     state,
                                                                                     pos),
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "}");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse___(input,
                                                                         state,
                                                                         pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            &input[start_pos..pos];
                                                                        Matched(pos,
                                                                                {
                                                                                    match cond
                                                                                        {
                                                                                        Some(_)
                                                                                        =>
                                                                                        {
                                                                                            let mut cond =
                                                                                                String::with_capacity(match_str.len()
                                                                                                                          -
                                                                                                                          1);
                                                                                            cond.push_str("{");
                                                                                            cond.push_str(&match_str[2..]);
                                                                                            (cond,
                                                                                             true)
                                                                                        }
                                                                                        None
                                                                                        =>
                                                                                        (match_str.to_string(),
                                                                                         false),
                                                                                    }
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_braced<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "{");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let choice_res =
                                                {
                                                    let seq_res =
                                                        parse_braced(input,
                                                                     state,
                                                                     pos);
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            slice_eq(input,
                                                                     state,
                                                                     pos, "")
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed =>
                                                parse_nonBraceCharacters(input,
                                                                         state,
                                                                         pos),
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "}");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_nonBraceCharacters<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res = parse_nonBraceCharacter(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1usize {
            Matched(repeat_pos, ())
        } else { Failed }
    }
}
fn parse_nonBraceCharacter<'input>(input: &'input str,
                                   state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '{' | '}' => state.mark_failure(pos, "[^{}]"),
            _ => Matched(next, ()),
        }
    } else { state.mark_failure(pos, "[^{}]") }
}
fn parse_equals<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "=");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_colon<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ":");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_semicolon<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ";");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_slash<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_and<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "&");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_not<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "!");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_dollar<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "$");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_question<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "?");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_star<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "*");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_starstar<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "**");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_plus<'input>(input: &'input str, state: &mut ParseState<'input>,
                      pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "+");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_plusplus<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "++");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_lparen<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "(");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_rparen<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ")");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_dot<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ".");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_returns<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "->");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_lbrace<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "{");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_rbrace<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "}");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_comma<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ",");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_integer<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<usize> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let (ch, next) =
                                                char_range_at(input, pos);
                                            match ch {
                                                '0' ...'9' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[0-9]"),
                                            }
                                        } else {
                                            state.mark_failure(pos, "[0-9]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                if repeat_value.len() >= 1usize {
                                    Matched(repeat_pos, ())
                                } else { Failed }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            { match_str.parse().unwrap() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, i) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { i })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifier<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_letter(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "_"),
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_letter(input,
                                                                         state,
                                                                         pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    parse_digit(input,
                                                                                state,
                                                                                pos);
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "_"),
                                                                }
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, chars) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { chars })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_literal<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, value) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "i") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, case_insensitive) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            LiteralExpr(value,
                                                                        case_insensitive.is_some())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, string) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { string })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_doubleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            s.into_iter().collect()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize) -> RuleResult<char> {
    {
        let choice_res = parse_simpleDoubleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleDoubleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState<'input>,
                                             pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\"");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                match_str.chars().next().unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\'");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_singleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\'");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            s.into_iter().collect()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize) -> RuleResult<char> {
    {
        let choice_res = parse_simpleSingleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleSingleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState<'input>,
                                             pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\'");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                match_str.chars().next().unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_class<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "[");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "^") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, inverted) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_classCharacterRange(input,
                                                                                      state,
                                                                                      pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_classCharacter(input,
                                                                                 state,
                                                                                 pos),
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, parts) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "]");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match slice_eq(input,
                                                                               state,
                                                                               pos,
                                                                               "i")
                                                                    {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        flags)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                CharSetExpr(inverted.is_some(),
                                                                                                            parts)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_classCharacterRange<'input>(input: &'input str,
                                     state: &mut ParseState<'input>,
                                     pos: usize) -> RuleResult<CharSetCase> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, state, pos);
            match seq_res {
                Matched(pos, begin) => {
                    {
                        let seq_res = slice_eq(input, state, pos, "-");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_bracketDelimitedCharacter(input,
                                                                        state,
                                                                        pos);
                                    match seq_res {
                                        Matched(pos, end) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            CharSetCase{start:
                                                                            begin,
                                                                        end:
                                                                            end,}
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_classCharacter<'input>(input: &'input str,
                                state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<CharSetCase> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, state, pos);
            match seq_res {
                Matched(pos, char_) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos,
                                { CharSetCase{start: char_, end: char_,} })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_bracketDelimitedCharacter<'input>(input: &'input str,
                                           state: &mut ParseState<'input>,
                                           pos: usize) -> RuleResult<char> {
    {
        let choice_res =
            parse_simpleBracketDelimitedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleBracketDelimitedCharacter<'input>(input: &'input str,
                                                 state:
                                                     &mut ParseState<'input>,
                                                 pos: usize)
 -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res = slice_eq(input, state, pos, "]");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                match_str.chars().next().unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_simpleEscapeSequence<'input>(input: &'input str,
                                      state: &mut ParseState<'input>,
                                      pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    {
                                        let choice_res =
                                            parse_digit(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    slice_eq(input, state,
                                                             pos, "x");
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "u");
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "U");
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    parse_eolChar(input,
                                                                                  state,
                                                                                  pos),
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = any_char(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match match_str[1..].chars().next().unwrap()
                                                                {
                                                                'n' => '\n',
                                                                'r' => '\r',
                                                                't' => '\t',
                                                                x => x,
                                                            }
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_zeroEscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\0");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    parse_digit(input, state, pos);
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { 0u8 as char })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex2EscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\x");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        u32::from_str_radix(match_str,
                                                                                            16)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_unicodeEscapeSequence<'input>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\u{");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1usize {
                                                Matched(repeat_pos, ())
                                            } else { Failed }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            u32::from_str_radix(match_str,
                                                                                16)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "}");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            char::from_u32(value.unwrap()).unwrap()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_eolEscapeSequence<'input>(input: &'input str,
                                   state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_eol(input, state, pos);
                        match seq_res {
                            Matched(pos, eol) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { '\n' })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_digit<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '0' ...'9' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9]"),
        }
    } else { state.mark_failure(pos, "[0-9]") }
}
fn parse_hexDigit<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '0' ...'9' | 'a' ...'f' | 'A' ...'F' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9a-fA-F]"),
        }
    } else { state.mark_failure(pos, "[0-9a-fA-F]") }
}
fn parse_letter<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let choice_res = parse_lowerCaseLetter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_upperCaseLetter(input, state, pos),
        }
    }
}
fn parse_lowerCaseLetter<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            'a' ...'z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[a-z]"),
        }
    } else { state.mark_failure(pos, "[a-z]") }
}
fn parse_upperCaseLetter<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            'A' ...'Z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[A-Z]"),
        }
    } else { state.mark_failure(pos, "[A-Z]") }
}
fn parse___<'input>(input: &'input str, state: &mut ParseState<'input>,
                    pos: usize) -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_eol(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_comment(input, state, pos),
                            }
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_comment<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let choice_res = parse_singleLineComment(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_multiLineComment(input, state, pos),
        }
    }
}
fn parse_singleLineComment<'input>(input: &'input str,
                                   state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "//");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            parse_eolChar(input, state, pos);
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        any_char(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_multiLineComment<'input>(input: &'input str,
                                  state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/*");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            {
                                                let assert_res =
                                                    slice_eq(input, state,
                                                             pos, "*/");
                                                match assert_res {
                                                    Failed =>
                                                    Matched(pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                any_char(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "*/")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_eol<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "\r\n");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "\r");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "\u{2028}");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "\u{2029}"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolChar<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '\n' | '\r' | '\u{2028}' | '\u{2029}' => Matched(next, ()),
            _ => state.mark_failure(pos, "[\n\r\u{2028}\u{2029}]"),
        }
    } else { state.mark_failure(pos, "[\n\r\u{2028}\u{2029}]") }
}
fn parse_whitespace<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            ' ' | '\t' | '\u{a0}' | '\u{feff}' | '\u{1680}' | '\u{180e}' |
            '\u{2000}' ...'\u{200a}' | '\u{202f}' | '\u{205f}' | '\u{3000}' =>
            Matched(next, ()),
            _ =>
            state.mark_failure(pos,
                               "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]"),
        }
    } else {
        state.mark_failure(pos,
                           "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]")
    }
}
pub fn grammar<'input>(input: &'input str) -> ParseResult<Grammar> {
    let mut state = ParseState::new();
    match parse_grammar(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
