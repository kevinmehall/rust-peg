// Generated by rust-peg. Do not edit.
#![allow(non_snake_case_functions, unused_variable)]

  use translate::*;
  use std::num::from_str_radix;
  use std::str;
  use std::char;

fn slice_eq(input: &str, pos: uint, m: &str) -> Result<(uint, ()), uint> {
    #![inline]
    let l = m.len();
    if input.len() >= pos + l && input.slice(pos, pos + l) == m {
        Ok((pos + l, ()))
    } else { Err(pos) }
}
fn any_char(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    #![inline]
    if input.len() > pos {
        Ok((input.char_range_at(pos).next, ()))
    } else { Err(pos) }
}
fn pos_to_line(input: &str, pos: uint) -> uint {
    let mut remaining = pos as int;
    let mut lineno: uint = 1;
    for line in input.lines() {
        remaining -= (line.len() as int) + 1;
        if remaining <= 0 { return lineno; }
        lineno += 1;
    }
    return lineno;
}
fn parse_grammar(input: &str, pos: uint) -> Result<(uint, Grammar), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            match parse_action(input, pos) {
                                Ok((newpos, value)) => {
                                    Ok((newpos, Some(value)))
                                },
                                Err(..) => { Ok((pos, None)) }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, header)) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_rust_use(input,
                                                                   pos);
                                                match step_res {
                                                    Ok((newpos, value)) => {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    },
                                                    Err(..) => { break ; }
                                                }
                                            }
                                            Ok((repeat_pos, repeat_value))
                                        };
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, imports)) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        let mut repeat_value =
                                                            vec!();
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let step_res =
                                                                parse_rule(input,
                                                                           pos);
                                                            match step_res {
                                                                Ok((newpos,
                                                                    value)) =>
                                                                {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                    repeat_value.push(value);
                                                                },
                                                                Err(..) => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        Ok((repeat_pos,
                                                            repeat_value))
                                                    };
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, rules)) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Ok((pos,
                                                                Grammar{initializer:
                                                                            header,
                                                                        imports:
                                                                            imports,
                                                                        rules:
                                                                            rules,}))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_rule(input: &str, pos: uint) -> Result<(uint, Rule), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_exportflag(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, exported)) => {
                    {
                        let seq_res = parse_identifier(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, name)) => {
                                {
                                    let seq_res =
                                        parse_returntype(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, returns)) => {
                                            {
                                                let seq_res =
                                                    parse_equals(input, pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                parse_expression(input,
                                                                                 pos);
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos,
                                                                    expression))
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_semicolon(input,
                                                                                                  pos)
                                                                                {
                                                                                Ok((newpos,
                                                                                    value))
                                                                                =>
                                                                                {
                                                                                    Ok((newpos,
                                                                                        Some(value)))
                                                                                },
                                                                                Err(..)
                                                                                =>
                                                                                {
                                                                                    Ok((pos,
                                                                                        None))
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Err(pos)
                                                                            =>
                                                                            {
                                                                                Err(pos)
                                                                            },
                                                                            Ok((pos,
                                                                                _))
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Ok((pos,
                                                                                        Rule{name:
                                                                                                 name,
                                                                                             expr:
                                                                                                 box() expression,
                                                                                             ret_type:
                                                                                                 returns,
                                                                                             exported:
                                                                                                 exported,}))
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_exportflag(input: &str, pos: uint) -> Result<(uint, bool), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, pos, "#[export]");
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, _)) => {
                            {
                                let seq_res = parse___(input, pos);
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, _)) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Ok((pos, true))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, pos, "");
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, _)) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Ok((pos, false))
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_returntype(input: &str, pos: uint) -> Result<(uint, String), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_returns(input, pos);
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, _)) => {
                            {
                                let seq_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_rust_type(input, pos);
                                            match seq_res {
                                                Err(pos) => { Err(pos) },
                                                Ok((pos, _)) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Ok((pos,
                                                            match_str.trim().to_string()))
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, tp)) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Ok((pos, tp))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let start_pos = pos;
                {
                    let match_str = input.slice(start_pos, pos);
                    Ok((pos, "()".to_string()))
                }
            }
        }
    }
}
fn parse_rust_use(input: &str, pos: uint) -> Result<(uint, RustUse), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "use");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res = parse___(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let seq_res = parse_rust_path(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, p)) => {
                                            {
                                                let seq_res =
                                                    parse___(input, pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let choice_res =
                                                                        {
                                                                            let start_pos =
                                                                                pos;
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             pos,
                                                                                             "::");
                                                                                match seq_res
                                                                                    {
                                                                                    Err(pos)
                                                                                    =>
                                                                                    {
                                                                                        Err(pos)
                                                                                    },
                                                                                    Ok((pos,
                                                                                        _))
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse___(input,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Err(pos)
                                                                                                =>
                                                                                                {
                                                                                                    Err(pos)
                                                                                                },
                                                                                                Ok((pos,
                                                                                                    _))
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            slice_eq(input,
                                                                                                                     pos,
                                                                                                                     "*");
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Err(pos)
                                                                                                            =>
                                                                                                            {
                                                                                                                Err(pos)
                                                                                                            },
                                                                                                            Ok((pos,
                                                                                                                _))
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        parse___(input,
                                                                                                                                 pos);
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Err(pos)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Err(pos)
                                                                                                                        },
                                                                                                                        Ok((pos,
                                                                                                                            _))
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    input.slice(start_pos,
                                                                                                                                                pos);
                                                                                                                                Ok((pos,
                                                                                                                                    RustUseGlob(p.clone())))
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        };
                                                                    match choice_res
                                                                        {
                                                                        Ok((pos,
                                                                            value))
                                                                        =>
                                                                        Ok((pos,
                                                                            value)),
                                                                        Err(..)
                                                                        => {
                                                                            let choice_res =
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     pos,
                                                                                                     "::");
                                                                                        match seq_res
                                                                                            {
                                                                                            Err(pos)
                                                                                            =>
                                                                                            {
                                                                                                Err(pos)
                                                                                            },
                                                                                            Ok((pos,
                                                                                                _))
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse___(input,
                                                                                                                 pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Err(pos)
                                                                                                        =>
                                                                                                        {
                                                                                                            Err(pos)
                                                                                                        },
                                                                                                        Ok((pos,
                                                                                                            _))
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    slice_eq(input,
                                                                                                                             pos,
                                                                                                                             "{");
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Err(pos)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        Err(pos)
                                                                                                                    },
                                                                                                                    Ok((pos,
                                                                                                                        _))
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse___(input,
                                                                                                                                         pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Err(pos)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    Err(pos)
                                                                                                                                },
                                                                                                                                Ok((pos,
                                                                                                                                    _))
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let seq_res =
                                                                                                                                            parse_identifier(input,
                                                                                                                                                             pos);
                                                                                                                                        match seq_res
                                                                                                                                            {
                                                                                                                                            Err(pos)
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                Err(pos)
                                                                                                                                            },
                                                                                                                                            Ok((pos,
                                                                                                                                                first))
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                {
                                                                                                                                                    let seq_res =
                                                                                                                                                        {
                                                                                                                                                            let mut repeat_pos =
                                                                                                                                                                pos;
                                                                                                                                                            let mut repeat_value =
                                                                                                                                                                vec!();
                                                                                                                                                            loop 
                                                                                                                                                                 {
                                                                                                                                                                let pos =
                                                                                                                                                                    repeat_pos;
                                                                                                                                                                let step_res =
                                                                                                                                                                    {
                                                                                                                                                                        let start_pos =
                                                                                                                                                                            pos;
                                                                                                                                                                        {
                                                                                                                                                                            let seq_res =
                                                                                                                                                                                slice_eq(input,
                                                                                                                                                                                         pos,
                                                                                                                                                                                         ",");
                                                                                                                                                                            match seq_res
                                                                                                                                                                                {
                                                                                                                                                                                Err(pos)
                                                                                                                                                                                =>
                                                                                                                                                                                {
                                                                                                                                                                                    Err(pos)
                                                                                                                                                                                },
                                                                                                                                                                                Ok((pos,
                                                                                                                                                                                    _))
                                                                                                                                                                                =>
                                                                                                                                                                                {
                                                                                                                                                                                    {
                                                                                                                                                                                        let seq_res =
                                                                                                                                                                                            parse___(input,
                                                                                                                                                                                                     pos);
                                                                                                                                                                                        match seq_res
                                                                                                                                                                                            {
                                                                                                                                                                                            Err(pos)
                                                                                                                                                                                            =>
                                                                                                                                                                                            {
                                                                                                                                                                                                Err(pos)
                                                                                                                                                                                            },
                                                                                                                                                                                            Ok((pos,
                                                                                                                                                                                                _))
                                                                                                                                                                                            =>
                                                                                                                                                                                            {
                                                                                                                                                                                                {
                                                                                                                                                                                                    let seq_res =
                                                                                                                                                                                                        parse_identifier(input,
                                                                                                                                                                                                                         pos);
                                                                                                                                                                                                    match seq_res
                                                                                                                                                                                                        {
                                                                                                                                                                                                        Err(pos)
                                                                                                                                                                                                        =>
                                                                                                                                                                                                        {
                                                                                                                                                                                                            Err(pos)
                                                                                                                                                                                                        },
                                                                                                                                                                                                        Ok((pos,
                                                                                                                                                                                                            i))
                                                                                                                                                                                                        =>
                                                                                                                                                                                                        {
                                                                                                                                                                                                            {
                                                                                                                                                                                                                let match_str =
                                                                                                                                                                                                                    input.slice(start_pos,
                                                                                                                                                                                                                                pos);
                                                                                                                                                                                                                Ok((pos,
                                                                                                                                                                                                                    i))
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    };
                                                                                                                                                                match step_res
                                                                                                                                                                    {
                                                                                                                                                                    Ok((newpos,
                                                                                                                                                                        value))
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        repeat_pos
                                                                                                                                                                            =
                                                                                                                                                                            newpos;
                                                                                                                                                                        repeat_value.push(value);
                                                                                                                                                                    },
                                                                                                                                                                    Err(..)
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        break
                                                                                                                                                                            ;
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                            Ok((repeat_pos,
                                                                                                                                                                repeat_value))
                                                                                                                                                        };
                                                                                                                                                    match seq_res
                                                                                                                                                        {
                                                                                                                                                        Err(pos)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            Err(pos)
                                                                                                                                                        },
                                                                                                                                                        Ok((pos,
                                                                                                                                                            rest))
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            {
                                                                                                                                                                let seq_res =
                                                                                                                                                                    slice_eq(input,
                                                                                                                                                                             pos,
                                                                                                                                                                             "}");
                                                                                                                                                                match seq_res
                                                                                                                                                                    {
                                                                                                                                                                    Err(pos)
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        Err(pos)
                                                                                                                                                                    },
                                                                                                                                                                    Ok((pos,
                                                                                                                                                                        _))
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        {
                                                                                                                                                                            let seq_res =
                                                                                                                                                                                parse___(input,
                                                                                                                                                                                         pos);
                                                                                                                                                                            match seq_res
                                                                                                                                                                                {
                                                                                                                                                                                Err(pos)
                                                                                                                                                                                =>
                                                                                                                                                                                {
                                                                                                                                                                                    Err(pos)
                                                                                                                                                                                },
                                                                                                                                                                                Ok((pos,
                                                                                                                                                                                    _))
                                                                                                                                                                                =>
                                                                                                                                                                                {
                                                                                                                                                                                    {
                                                                                                                                                                                        let match_str =
                                                                                                                                                                                            input.slice(start_pos,
                                                                                                                                                                                                        pos);
                                                                                                                                                                                        Ok((pos,
                                                                                                                                                                                            RustUseList(p.clone(),
                                                                                                                                                                                                        vec!(first)
                                                                                                                                                                                                            +
                                                                                                                                                                                                            rest)))
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                };
                                                                            match choice_res
                                                                                {
                                                                                Ok((pos,
                                                                                    value))
                                                                                =>
                                                                                Ok((pos,
                                                                                    value)),
                                                                                Err(..)
                                                                                =>
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     pos,
                                                                                                     "");
                                                                                        match seq_res
                                                                                            {
                                                                                            Err(pos)
                                                                                            =>
                                                                                            {
                                                                                                Err(pos)
                                                                                            },
                                                                                            Ok((pos,
                                                                                                _))
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let match_str =
                                                                                                        input.slice(start_pos,
                                                                                                                    pos);
                                                                                                    Ok((pos,
                                                                                                        RustUseSimple(p.clone())))
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos, v))
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            slice_eq(input,
                                                                                     pos,
                                                                                     ";");
                                                                        match seq_res
                                                                            {
                                                                            Err(pos)
                                                                            =>
                                                                            {
                                                                                Err(pos)
                                                                            },
                                                                            Ok((pos,
                                                                                _))
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse___(input,
                                                                                                 pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Err(pos)
                                                                                        =>
                                                                                        {
                                                                                            Err(pos)
                                                                                        },
                                                                                        Ok((pos,
                                                                                            _))
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    input.slice(start_pos,
                                                                                                                pos);
                                                                                                Ok((pos,
                                                                                                    v))
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_rust_path(input: &str, pos: uint) -> Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_identifier(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = ();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let seq_res =
                                                slice_eq(input, pos, "::");
                                            match seq_res {
                                                Err(pos) => { Err(pos) },
                                                Ok((pos, _)) => {
                                                    {
                                                        let seq_res =
                                                            parse___(input,
                                                                     pos);
                                                        match seq_res {
                                                            Err(pos) => {
                                                                Err(pos)
                                                            },
                                                            Ok((pos, _)) => {
                                                                parse_identifier(input,
                                                                                 pos)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        };
                                    match step_res {
                                        Ok((newpos, value)) => {
                                            repeat_pos = newpos;
                                            repeat_value = ();
                                        },
                                        Err(..) => { break ; }
                                    }
                                }
                                Ok((repeat_pos, repeat_value))
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, match_str.to_string()))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_rust_type(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let choice_res =
            {
                let seq_res = slice_eq(input, pos, "()");
                match seq_res {
                    Err(pos) => { Err(pos) },
                    Ok((pos, _)) => { parse___(input, pos) }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res =
                    {
                        let seq_res = slice_eq(input, pos, "[");
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let seq_res = parse_rust_type(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, pos, "]");
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        parse___(input, pos)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res =
                            {
                                let seq_res = parse_identifier(input, pos);
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, _)) => {
                                        {
                                            let seq_res =
                                                slice_eq(input, pos, "<");
                                            match seq_res {
                                                Err(pos) => { Err(pos) },
                                                Ok((pos, _)) => {
                                                    {
                                                        let seq_res =
                                                            parse_rust_type(input,
                                                                            pos);
                                                        match seq_res {
                                                            Err(pos) => {
                                                                Err(pos)
                                                            },
                                                            Ok((pos, _)) => {
                                                                {
                                                                    let seq_res =
                                                                        slice_eq(input,
                                                                                 pos,
                                                                                 ">");
                                                                    match seq_res
                                                                        {
                                                                        Err(pos)
                                                                        => {
                                                                            Err(pos)
                                                                        },
                                                                        Ok((pos,
                                                                            _))
                                                                        => {
                                                                            parse___(input,
                                                                                     pos)
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => {
                                let choice_res =
                                    {
                                        let seq_res =
                                            parse_identifier(input, pos);
                                        match seq_res {
                                            Err(pos) => { Err(pos) },
                                            Ok((pos, _)) => {
                                                {
                                                    let seq_res =
                                                        slice_eq(input, pos,
                                                                 "::");
                                                    match seq_res {
                                                        Err(pos) => {
                                                            Err(pos)
                                                        },
                                                        Ok((pos, _)) => {
                                                            parse_rust_type(input,
                                                                            pos)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => {
                                        let choice_res =
                                            {
                                                let seq_res =
                                                    slice_eq(input, pos, "(");
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                parse_rust_type(input,
                                                                                pos);
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos, _))
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            {
                                                                                let seq_res =
                                                                                    {
                                                                                        let seq_res =
                                                                                            parse___(input,
                                                                                                     pos);
                                                                                        match seq_res
                                                                                            {
                                                                                            Err(pos)
                                                                                            =>
                                                                                            {
                                                                                                Err(pos)
                                                                                            },
                                                                                            Ok((pos,
                                                                                                _))
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        slice_eq(input,
                                                                                                                 pos,
                                                                                                                 ",");
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Err(pos)
                                                                                                        =>
                                                                                                        {
                                                                                                            Err(pos)
                                                                                                        },
                                                                                                        Ok((pos,
                                                                                                            _))
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    parse___(input,
                                                                                                                             pos);
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Err(pos)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        Err(pos)
                                                                                                                    },
                                                                                                                    Ok((pos,
                                                                                                                        _))
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        parse_rust_type(input,
                                                                                                                                        pos)
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    };
                                                                                match seq_res
                                                                                    {
                                                                                    Err(pos)
                                                                                    =>
                                                                                    {
                                                                                        Err(pos)
                                                                                    },
                                                                                    Ok((pos,
                                                                                        _))
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let mut repeat_pos =
                                                                                                pos;
                                                                                            let mut repeat_value =
                                                                                                ();
                                                                                            loop 
                                                                                                 {
                                                                                                let pos =
                                                                                                    repeat_pos;
                                                                                                let step_res =
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse___(input,
                                                                                                                     pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Err(pos)
                                                                                                            =>
                                                                                                            {
                                                                                                                Err(pos)
                                                                                                            },
                                                                                                            Ok((pos,
                                                                                                                _))
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        slice_eq(input,
                                                                                                                                 pos,
                                                                                                                                 ",");
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Err(pos)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Err(pos)
                                                                                                                        },
                                                                                                                        Ok((pos,
                                                                                                                            _))
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let seq_res =
                                                                                                                                    parse___(input,
                                                                                                                                             pos);
                                                                                                                                match seq_res
                                                                                                                                    {
                                                                                                                                    Err(pos)
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        Err(pos)
                                                                                                                                    },
                                                                                                                                    Ok((pos,
                                                                                                                                        _))
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        parse_rust_type(input,
                                                                                                                                                        pos)
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    };
                                                                                                match step_res
                                                                                                    {
                                                                                                    Ok((newpos,
                                                                                                        value))
                                                                                                    =>
                                                                                                    {
                                                                                                        repeat_pos
                                                                                                            =
                                                                                                            newpos;
                                                                                                        repeat_value
                                                                                                            =
                                                                                                            ();
                                                                                                    },
                                                                                                    Err(..)
                                                                                                    =>
                                                                                                    {
                                                                                                        break
                                                                                                            ;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Ok((repeat_pos,
                                                                                                repeat_value))
                                                                                        }
                                                                                    }
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Err(pos)
                                                                            =>
                                                                            {
                                                                                Err(pos)
                                                                            },
                                                                            Ok((pos,
                                                                                _))
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        slice_eq(input,
                                                                                                 pos,
                                                                                                 ")");
                                                                                    match seq_res
                                                                                        {
                                                                                        Err(pos)
                                                                                        =>
                                                                                        {
                                                                                            Err(pos)
                                                                                        },
                                                                                        Ok((pos,
                                                                                            _))
                                                                                        =>
                                                                                        {
                                                                                            parse___(input,
                                                                                                     pos)
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            };
                                        match choice_res {
                                            Ok((pos, value)) =>
                                            Ok((pos, value)),
                                            Err(..) => {
                                                let seq_res =
                                                    parse_identifier(input,
                                                                     pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        slice_eq(input, pos,
                                                                 "")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_expression(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    parse_choice(input, pos)
}
fn parse_choice(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_sequence(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, head)) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse_slash(input, pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                parse_sequence(input,
                                                                               pos);
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos, s))
                                                                => {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Ok((pos,
                                                                            s))
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        };
                                    match step_res {
                                        Ok((newpos, value)) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        },
                                        Err(..) => { break ; }
                                    }
                                }
                                Ok((repeat_pos, repeat_value))
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, tail)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos,
                                        if tail.len() > 0 {
                                            let mut list = tail;
                                            list.unshift(head);
                                            ChoiceExpr(list)
                                        } else { head }))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_sequence(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res = parse_labeled(input, pos);
                                match step_res {
                                    Ok((newpos, value)) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    },
                                    Err(..) => { break ; }
                                }
                            }
                            Ok((repeat_pos, repeat_value))
                        };
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, elements)) => {
                            {
                                let seq_res = parse_action(input, pos);
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, code)) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Ok((pos,
                                                ActionExpr(elements, code)))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res = parse_prefixed(input, pos);
                                match step_res {
                                    Ok((newpos, value)) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    },
                                    Err(..) => { break ; }
                                }
                            }
                            Ok((repeat_pos, repeat_value))
                        };
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, elements)) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Ok((pos,
                                    if elements.len() != 1 {
                                        SequenceExpr(elements)
                                    } else {
                                        elements.move_iter().next().unwrap()
                                    }))
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_labeled(input: &str, pos: uint) -> Result<(uint, TaggedExpr), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, pos);
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, label)) => {
                            {
                                let seq_res = parse_colon(input, pos);
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, _)) => {
                                        {
                                            let seq_res =
                                                parse_prefixed(input, pos);
                                            match seq_res {
                                                Err(pos) => { Err(pos) },
                                                Ok((pos, expression)) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Ok((pos,
                                                            TaggedExpr{name:
                                                                           Some(label),
                                                                       expr:
                                                                           box() expression,}))
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let start_pos = pos;
                {
                    let seq_res = parse_prefixed(input, pos);
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, expr)) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Ok((pos,
                                    TaggedExpr{name: None,
                                               expr: box() expr,}))
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_prefixed(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_dollar(input, pos);
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, _)) => {
                            {
                                let seq_res = parse_suffixed(input, pos);
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, expression)) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Ok((pos, expression))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_and(input, pos);
                            match seq_res {
                                Err(pos) => { Err(pos) },
                                Ok((pos, _)) => {
                                    {
                                        let seq_res =
                                            parse_suffixed(input, pos);
                                        match seq_res {
                                            Err(pos) => { Err(pos) },
                                            Ok((pos, expression)) => {
                                                {
                                                    let match_str =
                                                        input.slice(start_pos,
                                                                    pos);
                                                    Ok((pos,
                                                        PosAssertExpr(box() expression)))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res = parse_not(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let seq_res =
                                                    parse_suffixed(input,
                                                                   pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, expression)) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Ok((pos,
                                                                NegAssertExpr(box() expression)))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => parse_suffixed(input, pos)
                        }
                    }
                }
            }
        }
    }
}
fn parse_suffixed(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_primary(input, pos);
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, expression)) => {
                            {
                                let seq_res = parse_question(input, pos);
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, _)) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Ok((pos,
                                                OptionalExpr(box() expression)))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_primary(input, pos);
                            match seq_res {
                                Err(pos) => { Err(pos) },
                                Ok((pos, expression)) => {
                                    {
                                        let seq_res = parse_star(input, pos);
                                        match seq_res {
                                            Err(pos) => { Err(pos) },
                                            Ok((pos, _)) => {
                                                {
                                                    let match_str =
                                                        input.slice(start_pos,
                                                                    pos);
                                                    Ok((pos,
                                                        ZeroOrMore(box() expression)))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res = parse_primary(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, expression)) => {
                                            {
                                                let seq_res =
                                                    parse_plus(input, pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Ok((pos,
                                                                OneOrMore(box() expression)))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => parse_primary(input, pos)
                        }
                    }
                }
            }
        }
    }
}
fn parse_primary(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, pos);
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, name)) => {
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            {
                                                let seq_res =
                                                    match parse_string(input,
                                                                       pos) {
                                                        Ok((newpos, value)) =>
                                                        {
                                                            Ok((newpos,
                                                                Some(value)))
                                                        },
                                                        Err(..) => {
                                                            Ok((pos, None))
                                                        }
                                                    };
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                parse_returntype(input,
                                                                                 pos);
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos, _))
                                                                => {
                                                                    parse_equals(input,
                                                                                 pos)
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            };
                                        match assert_res {
                                            Err(..) => Ok((pos, ())),
                                            Ok(..) => Err(pos)
                                        }
                                    };
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, _)) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Ok((pos, RuleExpr(name)))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res = parse_literal(input, pos);
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res = parse_class(input, pos);
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_dot(input, pos);
                                            match seq_res {
                                                Err(pos) => { Err(pos) },
                                                Ok((pos, _)) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Ok((pos, AnyCharExpr))
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_lparen(input, pos);
                                            match seq_res {
                                                Err(pos) => { Err(pos) },
                                                Ok((pos, _)) => {
                                                    {
                                                        let seq_res =
                                                            parse_expression(input,
                                                                             pos);
                                                        match seq_res {
                                                            Err(pos) => {
                                                                Err(pos)
                                                            },
                                                            Ok((pos,
                                                                expression))
                                                            => {
                                                                {
                                                                    let seq_res =
                                                                        parse_rparen(input,
                                                                                     pos);
                                                                    match seq_res
                                                                        {
                                                                        Err(pos)
                                                                        => {
                                                                            Err(pos)
                                                                        },
                                                                        Ok((pos,
                                                                            _))
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    input.slice(start_pos,
                                                                                                pos);
                                                                                Ok((pos,
                                                                                    expression))
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_action(input: &str, pos: uint) -> Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_braced(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, braced)) => {
                    {
                        let seq_res = parse___(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, braced))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_braced(input: &str, pos: uint) -> Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "{");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = ();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            {
                                                                let seq_res =
                                                                    parse_braced(input,
                                                                                 pos);
                                                                match seq_res
                                                                    {
                                                                    Err(pos)
                                                                    => {
                                                                        Err(pos)
                                                                    },
                                                                    Ok((pos,
                                                                        _)) =>
                                                                    {
                                                                        slice_eq(input,
                                                                                 pos,
                                                                                 "")
                                                                    }
                                                                }
                                                            };
                                                        match choice_res {
                                                            Ok((pos, value))
                                                            =>
                                                            Ok((pos, value)),
                                                            Err(..) =>
                                                            parse_nonBraceCharacters(input,
                                                                                     pos)
                                                        }
                                                    };
                                                match step_res {
                                                    Ok((newpos, value)) => {
                                                        repeat_pos = newpos;
                                                        repeat_value = ();
                                                    },
                                                    Err(..) => { break ; }
                                                }
                                            }
                                            Ok((repeat_pos, repeat_value))
                                        };
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos,
                                                    match_str.to_string()))
                                            }
                                        }
                                    }
                                }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, b)) => {
                                {
                                    let seq_res = slice_eq(input, pos, "}");
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos, b))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_nonBraceCharacters(input: &str, pos: uint) ->
 Result<(uint, ()), uint> {
    {
        let seq_res = parse_nonBraceCharacter(input, pos);
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => {
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = ();
                    loop  {
                        let pos = repeat_pos;
                        let step_res = parse_nonBraceCharacter(input, pos);
                        match step_res {
                            Ok((newpos, value)) => {
                                repeat_pos = newpos;
                                repeat_value = ();
                            },
                            Err(..) => { break ; }
                        }
                    }
                    Ok((repeat_pos, repeat_value))
                }
            }
        }
    }
}
fn parse_nonBraceCharacter(input: &str, pos: uint) ->
 Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch { '{' | '}' => Err(pos), _ => Ok((next, ())) }
    } else { Err(pos) }
}
fn parse_equals(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "=");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_colon(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, ":");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_semicolon(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, ";");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_slash(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "/");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_and(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "&");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_not(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "!");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_dollar(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "$");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_question(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "?");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_star(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "*");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_plus(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "+");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_lparen(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "(");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_rparen(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, ")");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_dot(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, ".");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_returns(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "->");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => { parse___(input, pos) }
        }
    }
}
fn parse_identifier(input: &str, pos: uint) -> Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let choice_res = parse_letter(input, pos);
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => slice_eq(input, pos, "_")
                                }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = ();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_letter(input,
                                                                         pos);
                                                        match choice_res {
                                                            Ok((pos, value))
                                                            =>
                                                            Ok((pos, value)),
                                                            Err(..) => {
                                                                let choice_res =
                                                                    parse_digit(input,
                                                                                pos);
                                                                match choice_res
                                                                    {
                                                                    Ok((pos,
                                                                        value))
                                                                    =>
                                                                    Ok((pos,
                                                                        value)),
                                                                    Err(..) =>
                                                                    slice_eq(input,
                                                                             pos,
                                                                             "_")
                                                                }
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Ok((newpos, value)) => {
                                                        repeat_pos = newpos;
                                                        repeat_value = ();
                                                    },
                                                    Err(..) => { break ; }
                                                }
                                            }
                                            Ok((repeat_pos, repeat_value))
                                        };
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos,
                                                    match_str.to_string()))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, chars)) => {
                    {
                        let seq_res = parse___(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, chars))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_literal(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_doubleQuotedString(input, pos);
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(..) => parse_singleQuotedString(input, pos)
                    }
                };
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, value)) => {
                    {
                        let seq_res =
                            match slice_eq(input, pos, "i") {
                                Ok((newpos, value)) => {
                                    Ok((newpos, Some(value)))
                                },
                                Err(..) => { Ok((pos, None)) }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, flags)) => {
                                {
                                    let seq_res = parse___(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos, LiteralExpr(value)))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_string(input: &str, pos: uint) -> Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = parse_doubleQuotedString(input, pos);
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(..) => parse_singleQuotedString(input, pos)
                    }
                };
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, string)) => {
                    {
                        let seq_res = parse___(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, string))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_doubleQuotedString(input: &str, pos: uint) ->
 Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\"");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_doubleQuotedCharacter(input,
                                                                    pos);
                                    match step_res {
                                        Ok((newpos, value)) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        },
                                        Err(..) => { break ; }
                                    }
                                }
                                Ok((repeat_pos, repeat_value))
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, s)) => {
                                {
                                    let seq_res = slice_eq(input, pos, "\"");
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos,
                                                    str::from_chars(s.as_slice())))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_doubleQuotedCharacter(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let choice_res = parse_simpleDoubleQuotedCharacter(input, pos);
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res = parse_simpleEscapeSequence(input, pos);
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res = parse_zeroEscapeSequence(input, pos);
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, pos);
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        pos);
                                        match choice_res {
                                            Ok((pos, value)) =>
                                            Ok((pos, value)),
                                            Err(..) =>
                                            parse_eolEscapeSequence(input,
                                                                    pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleDoubleQuotedCharacter(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res = slice_eq(input, pos, "\"");
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(..) => {
                                    let choice_res =
                                        slice_eq(input, pos, "\\");
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(..) => parse_eolChar(input, pos)
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Err(..) => Ok((pos, ())),
                        Ok(..) => Err(pos)
                    }
                };
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res = any_char(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, match_str.char_at(0)))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_singleQuotedString(input: &str, pos: uint) ->
 Result<(uint, String), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\'");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_singleQuotedCharacter(input,
                                                                    pos);
                                    match step_res {
                                        Ok((newpos, value)) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        },
                                        Err(..) => { break ; }
                                    }
                                }
                                Ok((repeat_pos, repeat_value))
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, s)) => {
                                {
                                    let seq_res = slice_eq(input, pos, "\'");
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos,
                                                    str::from_chars(s.as_slice())))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_singleQuotedCharacter(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let choice_res = parse_simpleSingleQuotedCharacter(input, pos);
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res = parse_simpleEscapeSequence(input, pos);
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res = parse_zeroEscapeSequence(input, pos);
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, pos);
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        pos);
                                        match choice_res {
                                            Ok((pos, value)) =>
                                            Ok((pos, value)),
                                            Err(..) =>
                                            parse_eolEscapeSequence(input,
                                                                    pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleSingleQuotedCharacter(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res = slice_eq(input, pos, "\'");
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(..) => {
                                    let choice_res =
                                        slice_eq(input, pos, "\\");
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(..) => parse_eolChar(input, pos)
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Err(..) => Ok((pos, ())),
                        Ok(..) => Err(pos)
                    }
                };
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res = any_char(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, match_str.char_at(0)))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_class(input: &str, pos: uint) -> Result<(uint, Expr), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "[");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            match slice_eq(input, pos, "^") {
                                Ok((newpos, value)) => {
                                    Ok((newpos, Some(value)))
                                },
                                Err(..) => { Ok((pos, None)) }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, inverted)) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_classCharacterRange(input,
                                                                                      pos);
                                                        match choice_res {
                                                            Ok((pos, value))
                                                            =>
                                                            Ok((pos, value)),
                                                            Err(..) =>
                                                            parse_classCharacter(input,
                                                                                 pos)
                                                        }
                                                    };
                                                match step_res {
                                                    Ok((newpos, value)) => {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    },
                                                    Err(..) => { break ; }
                                                }
                                            }
                                            Ok((repeat_pos, repeat_value))
                                        };
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, parts)) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, pos, "]");
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                match slice_eq(input,
                                                                               pos,
                                                                               "i")
                                                                    {
                                                                    Ok((newpos,
                                                                        value))
                                                                    => {
                                                                        Ok((newpos,
                                                                            Some(value)))
                                                                    },
                                                                    Err(..) =>
                                                                    {
                                                                        Ok((pos,
                                                                            None))
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos,
                                                                    flags)) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Err(pos)
                                                                            =>
                                                                            {
                                                                                Err(pos)
                                                                            },
                                                                            Ok((pos,
                                                                                _))
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Ok((pos,
                                                                                        CharSetExpr(inverted.is_some(),
                                                                                                    parts)))
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_classCharacterRange(input: &str, pos: uint) ->
 Result<(uint, CharSetCase), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, begin)) => {
                    {
                        let seq_res = slice_eq(input, pos, "-");
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let seq_res =
                                        parse_bracketDelimitedCharacter(input,
                                                                        pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, end)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos,
                                                    CharSetCase{start: begin,
                                                                end: end,}))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_classCharacter(input: &str, pos: uint) ->
 Result<(uint, CharSetCase), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, pos);
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, char_)) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Ok((pos, CharSetCase{start: char_, end: char_,}))
                    }
                }
            }
        }
    }
}
fn parse_bracketDelimitedCharacter(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let choice_res = parse_simpleBracketDelimitedCharacter(input, pos);
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res = parse_simpleEscapeSequence(input, pos);
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res = parse_zeroEscapeSequence(input, pos);
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, pos);
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        pos);
                                        match choice_res {
                                            Ok((pos, value)) =>
                                            Ok((pos, value)),
                                            Err(..) =>
                                            parse_eolEscapeSequence(input,
                                                                    pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleBracketDelimitedCharacter(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res = slice_eq(input, pos, "]");
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(..) => {
                                    let choice_res =
                                        slice_eq(input, pos, "\\");
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(..) => parse_eolChar(input, pos)
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Err(..) => Ok((pos, ())),
                        Ok(..) => Err(pos)
                    }
                };
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res = any_char(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, match_str.char_at(0)))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleEscapeSequence(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\\");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    {
                                        let choice_res =
                                            parse_digit(input, pos);
                                        match choice_res {
                                            Ok((pos, value)) =>
                                            Ok((pos, value)),
                                            Err(..) => {
                                                let choice_res =
                                                    slice_eq(input, pos, "x");
                                                match choice_res {
                                                    Ok((pos, value)) =>
                                                    Ok((pos, value)),
                                                    Err(..) => {
                                                        let choice_res =
                                                            slice_eq(input,
                                                                     pos,
                                                                     "u");
                                                        match choice_res {
                                                            Ok((pos, value))
                                                            =>
                                                            Ok((pos, value)),
                                                            Err(..) =>
                                                            parse_eolChar(input,
                                                                          pos)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match assert_res {
                                    Err(..) => Ok((pos, ())),
                                    Ok(..) => Err(pos)
                                }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let seq_res = any_char(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Ok((pos,
                                                    match match_str.char_at(1)
                                                        {
                                                        'n' => '\n',
                                                        'r' => '\r',
                                                        't' => '\t',
                                                        x => x
                                                    }))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_zeroEscapeSequence(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\\0");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let assert_res = parse_digit(input, pos);
                                match assert_res {
                                    Err(..) => Ok((pos, ())),
                                    Ok(..) => Err(pos)
                                }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, _)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, 0u8 as char))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_hexEscapeSequence(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\\x");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res = parse_hexDigit(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Ok((pos,
                                                                from_str_radix::<int>(match_str,
                                                                                      16)))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, value)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos,
                                        char::from_u32(value.unwrap() as
                                                           u32).unwrap()))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_unicodeEscapeSequence(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\\u");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res = parse_hexDigit(input, pos);
                                    match seq_res {
                                        Err(pos) => { Err(pos) },
                                        Ok((pos, _)) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   pos);
                                                match seq_res {
                                                    Err(pos) => { Err(pos) },
                                                    Ok((pos, _)) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               pos);
                                                            match seq_res {
                                                                Err(pos) => {
                                                                    Err(pos)
                                                                },
                                                                Ok((pos, _))
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Err(pos)
                                                                            =>
                                                                            {
                                                                                Err(pos)
                                                                            },
                                                                            Ok((pos,
                                                                                _))
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Ok((pos,
                                                                                        from_str_radix::<int>(match_str,
                                                                                                              16)))
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, value)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos,
                                        char::from_u32(value.unwrap() as
                                                           u32).unwrap()))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolEscapeSequence(input: &str, pos: uint) ->
 Result<(uint, char), uint> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, pos, "\\");
            match seq_res {
                Err(pos) => { Err(pos) },
                Ok((pos, _)) => {
                    {
                        let seq_res = parse_eol(input, pos);
                        match seq_res {
                            Err(pos) => { Err(pos) },
                            Ok((pos, eol)) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Ok((pos, '\n'))
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_digit(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch { '0' ..'9' => Ok((next, ())), _ => Err(pos) }
    } else { Err(pos) }
}
fn parse_hexDigit(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch {
            '0' ..'9' | 'a' ..'f' | 'A' ..'F' => Ok((next, ())),
            _ => Err(pos)
        }
    } else { Err(pos) }
}
fn parse_letter(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let choice_res = parse_lowerCaseLetter(input, pos);
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => parse_upperCaseLetter(input, pos)
        }
    }
}
fn parse_lowerCaseLetter(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch { 'a' ..'z' => Ok((next, ())), _ => Err(pos) }
    } else { Err(pos) }
}
fn parse_upperCaseLetter(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch { 'A' ..'Z' => Ok((next, ())), _ => Err(pos) }
    } else { Err(pos) }
}
fn parse___(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = ();
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, pos);
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(..) => {
                            let choice_res = parse_eol(input, pos);
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(..) => parse_comment(input, pos)
                            }
                        }
                    }
                };
            match step_res {
                Ok((newpos, value)) => {
                    repeat_pos = newpos;
                    repeat_value = ();
                },
                Err(..) => { break ; }
            }
        }
        Ok((repeat_pos, repeat_value))
    }
}
fn parse_comment(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let choice_res = parse_singleLineComment(input, pos);
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => parse_multiLineComment(input, pos)
        }
    }
}
fn parse_singleLineComment(input: &str, pos: uint) ->
 Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "//");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => {
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = ();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            parse_eolChar(input, pos);
                                        match assert_res {
                                            Err(..) => Ok((pos, ())),
                                            Ok(..) => Err(pos)
                                        }
                                    };
                                match seq_res {
                                    Err(pos) => { Err(pos) },
                                    Ok((pos, _)) => { any_char(input, pos) }
                                }
                            };
                        match step_res {
                            Ok((newpos, value)) => {
                                repeat_pos = newpos;
                                repeat_value = ();
                            },
                            Err(..) => { break ; }
                        }
                    }
                    Ok((repeat_pos, repeat_value))
                }
            }
        }
    }
}
fn parse_multiLineComment(input: &str, pos: uint) ->
 Result<(uint, ()), uint> {
    {
        let seq_res = slice_eq(input, pos, "/*");
        match seq_res {
            Err(pos) => { Err(pos) },
            Ok((pos, _)) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = ();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            {
                                                let assert_res =
                                                    slice_eq(input, pos,
                                                             "*/");
                                                match assert_res {
                                                    Err(..) => Ok((pos, ())),
                                                    Ok(..) => Err(pos)
                                                }
                                            };
                                        match seq_res {
                                            Err(pos) => { Err(pos) },
                                            Ok((pos, _)) => {
                                                any_char(input, pos)
                                            }
                                        }
                                    };
                                match step_res {
                                    Ok((newpos, value)) => {
                                        repeat_pos = newpos;
                                        repeat_value = ();
                                    },
                                    Err(..) => { break ; }
                                }
                            }
                            Ok((repeat_pos, repeat_value))
                        };
                    match seq_res {
                        Err(pos) => { Err(pos) },
                        Ok((pos, _)) => { slice_eq(input, pos, "*/") }
                    }
                }
            }
        }
    }
}
fn parse_eol(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    {
        let choice_res = slice_eq(input, pos, "\n");
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(..) => {
                let choice_res = slice_eq(input, pos, "\r\n");
                match choice_res {
                    Ok((pos, value)) => Ok((pos, value)),
                    Err(..) => {
                        let choice_res = slice_eq(input, pos, "\r");
                        match choice_res {
                            Ok((pos, value)) => Ok((pos, value)),
                            Err(..) => {
                                let choice_res =
                                    slice_eq(input, pos, "\u2028");
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(..) => slice_eq(input, pos, "\u2029")
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolChar(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch {
            '\n' | '\r' | '\u2028' | '\u2029' => Ok((next, ())),
            _ => Err(pos)
        }
    } else { Err(pos) }
}
fn parse_whitespace(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        let ::std::str::CharRange{ch: ch, next: next} =
            input.char_range_at(pos);
        match ch {
            ' ' | '\t' | '\xa0' | '\ufeff' | '\u1680' | '\u180e' | '\u2000'
            ..'\u200a' | '\u202f' | '\u205f' | '\u3000' => Ok((next, ())),
            _ => Err(pos)
        }
    } else { Err(pos) }
}
pub fn grammar(input: &str) -> Result<Grammar, String> {
    match parse_grammar(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(format!("Expected end of input at {}" , pos_to_line
                            ( input , pos )))
            }
        },
        Err(pos) => Err(format!("Error at {}" , pos_to_line ( input , pos )))
    }
}
