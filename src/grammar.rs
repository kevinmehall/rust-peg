// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use translate::*;
use std::num::from_str_radix;
use std::char;
enum ParseResult<T> { Matched(uint, T), Failed, }
struct ParseState {
    max_err_pos: uint,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: uint, expected: &'static str) ->
     ParseResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: uint, m: &'static str)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           input.as_bytes().slice(pos, pos + l) == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn any_char(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        Matched(input.char_range_at(pos).next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: uint) -> (uint, uint) {
    let mut remaining = pos;
    let mut lineno: uint = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
fn parse_grammar<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Grammar> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_rust_use(input, state, pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, imports) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_rule(input, state,
                                                               pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, rules) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            Grammar{imports:
                                                                        imports,
                                                                    rules:
                                                                        rules,}
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rule<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Rule> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_exportflag(input, state, pos);
            match seq_res {
                Matched(pos, exported) => {
                    {
                        let seq_res = parse_identifier(input, state, pos);
                        match seq_res {
                            Matched(pos, name) => {
                                {
                                    let seq_res =
                                        parse_returntype(input, state, pos);
                                    match seq_res {
                                        Matched(pos, returns) => {
                                            {
                                                let seq_res =
                                                    parse_equals(input, state,
                                                                 pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_expression(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        expression)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            match parse_semicolon(input,
                                                                                                  state,
                                                                                                  pos)
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    Matched(newpos,
                                                                                            Some(value))
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    Matched(pos,
                                                                                            None)
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                Rule{name:
                                                                                                         name,
                                                                                                     expr:
                                                                                                         box() expression,
                                                                                                     ret_type:
                                                                                                         returns,
                                                                                                     exported:
                                                                                                         exported,}
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_exportflag<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<bool> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "#[export]");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed =>
                                slice_eq(input, state, pos, "#[pub]"),
                            }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res = parse___(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { true })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos, { false })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_returntype<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<String> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_returns(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_rust_type(input, state,
                                                                pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Matched(pos,
                                                                {
                                                                    match_str.trim().to_string()
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, tp) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { tp })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let match_str = input.slice(start_pos, pos);
                    Matched(pos, { "()".to_string() })
                }
            }
        }
    }
}
fn parse_rust_use<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<RustUse> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "use");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_rust_path(input, state, pos);
                                    match seq_res {
                                        Matched(pos, p) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let choice_res =
                                                                        {
                                                                            let start_pos =
                                                                                pos;
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             "::");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse___(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            slice_eq(input,
                                                                                                                     state,
                                                                                                                     pos,
                                                                                                                     "*");
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        parse___(input,
                                                                                                                                 state,
                                                                                                                                 pos);
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                _)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let match_str =
                                                                                                                                    input.slice(start_pos,
                                                                                                                                                pos);
                                                                                                                                Matched(pos,
                                                                                                                                        {
                                                                                                                                            RustUseGlob(p.clone())
                                                                                                                                        })
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        };
                                                                    match choice_res
                                                                        {
                                                                        Matched(pos,
                                                                                value)
                                                                        =>
                                                                        Matched(pos,
                                                                                value),
                                                                        Failed
                                                                        => {
                                                                            let choice_res =
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "::");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse___(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    slice_eq(input,
                                                                                                                             state,
                                                                                                                             pos,
                                                                                                                             "{");
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Matched(pos,
                                                                                                                            _)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse___(input,
                                                                                                                                         state,
                                                                                                                                         pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        _)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let seq_res =
                                                                                                                                            {
                                                                                                                                                let mut repeat_pos =
                                                                                                                                                    pos;
                                                                                                                                                let mut repeat_value =
                                                                                                                                                    vec!();
                                                                                                                                                loop 
                                                                                                                                                     {
                                                                                                                                                    let pos =
                                                                                                                                                        repeat_pos;
                                                                                                                                                    let pos =
                                                                                                                                                        if repeat_value.len()
                                                                                                                                                               >
                                                                                                                                                               0
                                                                                                                                                           {
                                                                                                                                                            let sep_res =
                                                                                                                                                                {
                                                                                                                                                                    let seq_res =
                                                                                                                                                                        slice_eq(input,
                                                                                                                                                                                 state,
                                                                                                                                                                                 pos,
                                                                                                                                                                                 ",");
                                                                                                                                                                    match seq_res
                                                                                                                                                                        {
                                                                                                                                                                        Matched(pos,
                                                                                                                                                                                _)
                                                                                                                                                                        =>
                                                                                                                                                                        {
                                                                                                                                                                            parse___(input,
                                                                                                                                                                                     state,
                                                                                                                                                                                     pos)
                                                                                                                                                                        }
                                                                                                                                                                        Failed
                                                                                                                                                                        =>
                                                                                                                                                                        Failed,
                                                                                                                                                                    }
                                                                                                                                                                };
                                                                                                                                                            match sep_res
                                                                                                                                                                {
                                                                                                                                                                Matched(newpos,
                                                                                                                                                                        _)
                                                                                                                                                                =>
                                                                                                                                                                {
                                                                                                                                                                    newpos
                                                                                                                                                                }
                                                                                                                                                                Failed
                                                                                                                                                                =>
                                                                                                                                                                break
                                                                                                                                                                    ,
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            pos
                                                                                                                                                        };
                                                                                                                                                    let step_res =
                                                                                                                                                        parse_identifier(input,
                                                                                                                                                                         state,
                                                                                                                                                                         pos);
                                                                                                                                                    match step_res
                                                                                                                                                        {
                                                                                                                                                        Matched(newpos,
                                                                                                                                                                value)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            repeat_pos
                                                                                                                                                                =
                                                                                                                                                                newpos;
                                                                                                                                                            repeat_value.push(value);
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            break
                                                                                                                                                                ;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                if repeat_value.len()
                                                                                                                                                       >=
                                                                                                                                                       1u
                                                                                                                                                   {
                                                                                                                                                    Matched(repeat_pos,
                                                                                                                                                            repeat_value)
                                                                                                                                                } else {
                                                                                                                                                    Failed
                                                                                                                                                }
                                                                                                                                            };
                                                                                                                                        match seq_res
                                                                                                                                            {
                                                                                                                                            Matched(pos,
                                                                                                                                                    names)
                                                                                                                                            =>
                                                                                                                                            {
                                                                                                                                                {
                                                                                                                                                    let seq_res =
                                                                                                                                                        slice_eq(input,
                                                                                                                                                                 state,
                                                                                                                                                                 pos,
                                                                                                                                                                 "}");
                                                                                                                                                    match seq_res
                                                                                                                                                        {
                                                                                                                                                        Matched(pos,
                                                                                                                                                                _)
                                                                                                                                                        =>
                                                                                                                                                        {
                                                                                                                                                            {
                                                                                                                                                                let seq_res =
                                                                                                                                                                    parse___(input,
                                                                                                                                                                             state,
                                                                                                                                                                             pos);
                                                                                                                                                                match seq_res
                                                                                                                                                                    {
                                                                                                                                                                    Matched(pos,
                                                                                                                                                                            _)
                                                                                                                                                                    =>
                                                                                                                                                                    {
                                                                                                                                                                        {
                                                                                                                                                                            let match_str =
                                                                                                                                                                                input.slice(start_pos,
                                                                                                                                                                                            pos);
                                                                                                                                                                            Matched(pos,
                                                                                                                                                                                    {
                                                                                                                                                                                        RustUseList(p.clone(),
                                                                                                                                                                                                    names)
                                                                                                                                                                                    })
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                    Failed
                                                                                                                                                                    =>
                                                                                                                                                                    Failed,
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        Failed
                                                                                                                                                        =>
                                                                                                                                                        Failed,
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            Failed
                                                                                                                                            =>
                                                                                                                                            Failed,
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                Failed,
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed
                                                                                                                    =>
                                                                                                                    Failed,
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                };
                                                                            match choice_res
                                                                                {
                                                                                Matched(pos,
                                                                                        value)
                                                                                =>
                                                                                Matched(pos,
                                                                                        value),
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    let start_pos =
                                                                                        pos;
                                                                                    {
                                                                                        let seq_res =
                                                                                            slice_eq(input,
                                                                                                     state,
                                                                                                     pos,
                                                                                                     "");
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let match_str =
                                                                                                        input.slice(start_pos,
                                                                                                                    pos);
                                                                                                    Matched(pos,
                                                                                                            {
                                                                                                                RustUseSimple(p.clone())
                                                                                                            })
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        v) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            slice_eq(input,
                                                                                     state,
                                                                                     pos,
                                                                                     ";");
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    input.slice(start_pos,
                                                                                                                pos);
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            v
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rust_path<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let pos =
                            if repeat_value.len() > 0 {
                                let sep_res =
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, "::");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse___(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match sep_res {
                                    Matched(newpos, _) => { newpos }
                                    Failed => break ,
                                }
                            } else { pos };
                        let step_res = parse_identifier(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1u {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_rust_type<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<()> {
    {
        let choice_res =
            {
                let seq_res = slice_eq(input, state, pos, "()");
                match seq_res {
                    Matched(pos, _) => { parse___(input, state, pos) }
                    Failed => Failed,
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let seq_res = slice_eq(input, state, pos, "[");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_rust_type(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "]");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        parse___(input, state,
                                                                 pos)
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let seq_res =
                                    slice_eq(input, state, pos, "&");
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                match {
                                                          let seq_res =
                                                              slice_eq(input,
                                                                       state,
                                                                       pos,
                                                                       "\'");
                                                          match seq_res {
                                                              Matched(pos, _)
                                                              => {
                                                                  parse_identifier(input,
                                                                                   state,
                                                                                   pos)
                                                              }
                                                              Failed =>
                                                              Failed,
                                                          }
                                                      } {
                                                    Matched(newpos, value) =>
                                                    {
                                                        Matched(newpos,
                                                                Some(value))
                                                    }
                                                    Failed => {
                                                        Matched(pos, None)
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    parse_rust_type(input,
                                                                    state,
                                                                    pos)
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let seq_res =
                                            parse_identifier(input, state,
                                                             pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        slice_eq(input, state,
                                                                 pos, "<");
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            {
                                                                let seq_res =
                                                                    {
                                                                        let mut repeat_pos =
                                                                            pos;
                                                                        let mut repeat_value =
                                                                            vec!();
                                                                        loop 
                                                                             {
                                                                            let pos =
                                                                                repeat_pos;
                                                                            let pos =
                                                                                if repeat_value.len()
                                                                                       >
                                                                                       0
                                                                                   {
                                                                                    let sep_res =
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse___(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        _)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            slice_eq(input,
                                                                                                                     state,
                                                                                                                     pos,
                                                                                                                     ",");
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                parse___(input,
                                                                                                                         state,
                                                                                                                         pos)
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        };
                                                                                    match sep_res
                                                                                        {
                                                                                        Matched(newpos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            newpos
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        break
                                                                                            ,
                                                                                    }
                                                                                } else {
                                                                                    pos
                                                                                };
                                                                            let step_res =
                                                                                parse_rust_type(input,
                                                                                                state,
                                                                                                pos);
                                                                            match step_res
                                                                                {
                                                                                Matched(newpos,
                                                                                        value)
                                                                                =>
                                                                                {
                                                                                    repeat_pos
                                                                                        =
                                                                                        newpos;
                                                                                    repeat_value.push(value);
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                {
                                                                                    break
                                                                                        ;
                                                                                }
                                                                            }
                                                                        }
                                                                        if repeat_value.len()
                                                                               >=
                                                                               1u
                                                                           {
                                                                            Matched(repeat_pos,
                                                                                    ())
                                                                        } else {
                                                                            Failed
                                                                        }
                                                                    };
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let seq_res =
                                                                                slice_eq(input,
                                                                                         state,
                                                                                         pos,
                                                                                         ">");
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        _)
                                                                                =>
                                                                                {
                                                                                    parse___(input,
                                                                                             state,
                                                                                             pos)
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            {
                                                let seq_res =
                                                    parse_identifier(input,
                                                                     state,
                                                                     pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "::");
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_rust_type(input,
                                                                                    state,
                                                                                    pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    {
                                                        let seq_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "(");
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let seq_res =
                                                                        {
                                                                            let mut repeat_pos =
                                                                                pos;
                                                                            let mut repeat_value =
                                                                                vec!();
                                                                            loop 
                                                                                 {
                                                                                let pos =
                                                                                    repeat_pos;
                                                                                let pos =
                                                                                    if repeat_value.len()
                                                                                           >
                                                                                           0
                                                                                       {
                                                                                        let sep_res =
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse___(input,
                                                                                                             state,
                                                                                                             pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                slice_eq(input,
                                                                                                                         state,
                                                                                                                         pos,
                                                                                                                         ",");
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    parse___(input,
                                                                                                                             state,
                                                                                                                             pos)
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            };
                                                                                        match sep_res
                                                                                            {
                                                                                            Matched(newpos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                newpos
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            break
                                                                                                ,
                                                                                        }
                                                                                    } else {
                                                                                        pos
                                                                                    };
                                                                                let step_res =
                                                                                    parse_rust_type(input,
                                                                                                    state,
                                                                                                    pos);
                                                                                match step_res
                                                                                    {
                                                                                    Matched(newpos,
                                                                                            value)
                                                                                    =>
                                                                                    {
                                                                                        repeat_pos
                                                                                            =
                                                                                            newpos;
                                                                                        repeat_value.push(value);
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    {
                                                                                        break
                                                                                            ;
                                                                                    }
                                                                                }
                                                                            }
                                                                            if repeat_value.len()
                                                                                   >=
                                                                                   1u
                                                                               {
                                                                                Matched(repeat_pos,
                                                                                        ())
                                                                            } else {
                                                                                Failed
                                                                            }
                                                                        };
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    slice_eq(input,
                                                                                             state,
                                                                                             pos,
                                                                                             ")");
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos)
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let seq_res =
                                                            parse_identifier(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "")
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_expression<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<Expr> {
    parse_choice(input, state, pos)
}
fn parse_choice<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_sequence(input, state, pos);
            match seq_res {
                Matched(pos, head) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let start_pos = pos;
                                            {
                                                let seq_res =
                                                    parse_slash(input, state,
                                                                pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_sequence(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        s) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    s
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, tail) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                if tail.len() > 0 {
                                                    let mut list = tail;
                                                    list.insert(0, head);
                                                    ChoiceExpr(list)
                                                } else { head }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_sequence<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_labeled(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, elements) => {
                            {
                                let seq_res = parse_action(input, state, pos);
                                match seq_res {
                                    Matched(pos, code) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos,
                                                    {
                                                        ActionExpr(elements,
                                                                   code)
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            let mut repeat_value = vec!();
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    parse_prefixed(input, state, pos);
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                        repeat_value.push(value);
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, repeat_value)
                        };
                    match seq_res {
                        Matched(pos, elements) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos,
                                        {
                                            if elements.len() != 1 {
                                                SequenceExpr(elements)
                                            } else {
                                                elements.into_iter().next().unwrap()
                                            }
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_labeled<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<TaggedExpr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, label) => {
                            {
                                let seq_res = parse_colon(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                parse_prefixed(input, state,
                                                               pos);
                                            match seq_res {
                                                Matched(pos, expression) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Matched(pos,
                                                                {
                                                                    TaggedExpr{name:
                                                                                   Some(label),
                                                                               expr:
                                                                                   box() expression,}
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_prefixed(input, state, pos);
                    match seq_res {
                        Matched(pos, expr) => {
                            {
                                let match_str = input.slice(start_pos, pos);
                                Matched(pos,
                                        {
                                            TaggedExpr{name: None,
                                                       expr: box() expr,}
                                        })
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_prefixed<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_dollar(input, state, pos);
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    parse_suffixed(input, state, pos);
                                match seq_res {
                                    Matched(pos, expression) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { expression })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_and(input, state, pos);
                            match seq_res {
                                Matched(pos, _) => {
                                    {
                                        let seq_res =
                                            parse_suffixed(input, state, pos);
                                        match seq_res {
                                            Matched(pos, expression) => {
                                                {
                                                    let match_str =
                                                        input.slice(start_pos,
                                                                    pos);
                                                    Matched(pos,
                                                            {
                                                                PosAssertExpr(box() expression)
                                                            })
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_not(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_suffixed(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, expression)
                                                    => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        NegAssertExpr(box() expression)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => parse_suffixed(input, state, pos),
                        }
                    }
                }
            }
        }
    }
}
fn parse_suffixed<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_primary(input, state, pos);
                    match seq_res {
                        Matched(pos, expression) => {
                            {
                                let seq_res =
                                    parse_question(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos,
                                                    {
                                                        OptionalExpr(box() expression)
                                                    })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    {
                        let start_pos = pos;
                        {
                            let seq_res = parse_primary(input, state, pos);
                            match seq_res {
                                Matched(pos, expression) => {
                                    {
                                        let seq_res =
                                            parse_starstar(input, state, pos);
                                        match seq_res {
                                            Matched(pos, _) => {
                                                {
                                                    let seq_res =
                                                        parse_primary(input,
                                                                      state,
                                                                      pos);
                                                    match seq_res {
                                                        Matched(pos, sep) => {
                                                            {
                                                                let match_str =
                                                                    input.slice(start_pos,
                                                                                pos);
                                                                Matched(pos,
                                                                        {
                                                                            Repeat(box() expression,
                                                                                   0,
                                                                                   None,
                                                                                   Some(box() sep))
                                                                        })
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                    };
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_primary(input, state, pos);
                                    match seq_res {
                                        Matched(pos, expression) => {
                                            {
                                                let seq_res =
                                                    parse_plusplus(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_primary(input,
                                                                              state,
                                                                              pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        sep)
                                                                => {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    Repeat(box() expression,
                                                                                           1,
                                                                                           None,
                                                                                           Some(box() sep))
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_primary(input, state,
                                                              pos);
                                            match seq_res {
                                                Matched(pos, expression) => {
                                                    {
                                                        let seq_res =
                                                            parse_star(input,
                                                                       state,
                                                                       pos);
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        input.slice(start_pos,
                                                                                    pos);
                                                                    Matched(pos,
                                                                            {
                                                                                Repeat(box() expression,
                                                                                       0,
                                                                                       None,
                                                                                       None)
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            {
                                                let start_pos = pos;
                                                {
                                                    let seq_res =
                                                        parse_primary(input,
                                                                      state,
                                                                      pos);
                                                    match seq_res {
                                                        Matched(pos,
                                                                expression) =>
                                                        {
                                                            {
                                                                let seq_res =
                                                                    parse_plus(input,
                                                                               state,
                                                                               pos);
                                                                match seq_res
                                                                    {
                                                                    Matched(pos,
                                                                            _)
                                                                    => {
                                                                        {
                                                                            let match_str =
                                                                                input.slice(start_pos,
                                                                                            pos);
                                                                            Matched(pos,
                                                                                    {
                                                                                        Repeat(box() expression,
                                                                                               1,
                                                                                               None,
                                                                                               None)
                                                                                    })
                                                                        }
                                                                    }
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                            };
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    {
                                                        let start_pos = pos;
                                                        {
                                                            let seq_res =
                                                                parse_primary(input,
                                                                              state,
                                                                              pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        expression)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse_lbrace(input,
                                                                                         state,
                                                                                         pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_integer(input,
                                                                                                      state,
                                                                                                      pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                n)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_rbrace(input,
                                                                                                                 state,
                                                                                                                 pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let match_str =
                                                                                                                input.slice(start_pos,
                                                                                                                            pos);
                                                                                                            Matched(pos,
                                                                                                                    {
                                                                                                                        Repeat(box() expression,
                                                                                                                               n,
                                                                                                                               Some(n),
                                                                                                                               None)
                                                                                                                    })
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    };
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            {
                                                                let start_pos =
                                                                    pos;
                                                                {
                                                                    let seq_res =
                                                                        parse_primary(input,
                                                                                      state,
                                                                                      pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                expression)
                                                                        => {
                                                                            {
                                                                                let seq_res =
                                                                                    parse_lbrace(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                match seq_res
                                                                                    {
                                                                                    Matched(pos,
                                                                                            _)
                                                                                    =>
                                                                                    {
                                                                                        {
                                                                                            let seq_res =
                                                                                                parse_integer(input,
                                                                                                              state,
                                                                                                              pos);
                                                                                            match seq_res
                                                                                                {
                                                                                                Matched(pos,
                                                                                                        min)
                                                                                                =>
                                                                                                {
                                                                                                    {
                                                                                                        let seq_res =
                                                                                                            parse_comma(input,
                                                                                                                        state,
                                                                                                                        pos);
                                                                                                        match seq_res
                                                                                                            {
                                                                                                            Matched(pos,
                                                                                                                    _)
                                                                                                            =>
                                                                                                            {
                                                                                                                {
                                                                                                                    let seq_res =
                                                                                                                        match parse_integer(input,
                                                                                                                                            state,
                                                                                                                                            pos)
                                                                                                                            {
                                                                                                                            Matched(newpos,
                                                                                                                                    value)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                Matched(newpos,
                                                                                                                                        Some(value))
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                Matched(pos,
                                                                                                                                        None)
                                                                                                                            }
                                                                                                                        };
                                                                                                                    match seq_res
                                                                                                                        {
                                                                                                                        Matched(pos,
                                                                                                                                max)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            {
                                                                                                                                let seq_res =
                                                                                                                                    parse_rbrace(input,
                                                                                                                                                 state,
                                                                                                                                                 pos);
                                                                                                                                match seq_res
                                                                                                                                    {
                                                                                                                                    Matched(pos,
                                                                                                                                            _)
                                                                                                                                    =>
                                                                                                                                    {
                                                                                                                                        {
                                                                                                                                            let match_str =
                                                                                                                                                input.slice(start_pos,
                                                                                                                                                            pos);
                                                                                                                                            Matched(pos,
                                                                                                                                                    {
                                                                                                                                                        Repeat(box() expression,
                                                                                                                                                               min,
                                                                                                                                                               max,
                                                                                                                                                               None)
                                                                                                                                                    })
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    Failed
                                                                                                                                    =>
                                                                                                                                    Failed,
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        Failed,
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            Failed
                                                                                                            =>
                                                                                                            Failed,
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                Failed
                                                                                                =>
                                                                                                Failed,
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    Failed
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            };
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    {
                                                                        let start_pos =
                                                                            pos;
                                                                        {
                                                                            let seq_res =
                                                                                parse_primary(input,
                                                                                              state,
                                                                                              pos);
                                                                            match seq_res
                                                                                {
                                                                                Matched(pos,
                                                                                        expression)
                                                                                =>
                                                                                {
                                                                                    {
                                                                                        let seq_res =
                                                                                            parse_lbrace(input,
                                                                                                         state,
                                                                                                         pos);
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        parse_comma(input,
                                                                                                                    state,
                                                                                                                    pos);
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            {
                                                                                                                let seq_res =
                                                                                                                    match parse_integer(input,
                                                                                                                                        state,
                                                                                                                                        pos)
                                                                                                                        {
                                                                                                                        Matched(newpos,
                                                                                                                                value)
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Matched(newpos,
                                                                                                                                    Some(value))
                                                                                                                        }
                                                                                                                        Failed
                                                                                                                        =>
                                                                                                                        {
                                                                                                                            Matched(pos,
                                                                                                                                    None)
                                                                                                                        }
                                                                                                                    };
                                                                                                                match seq_res
                                                                                                                    {
                                                                                                                    Matched(pos,
                                                                                                                            max)
                                                                                                                    =>
                                                                                                                    {
                                                                                                                        {
                                                                                                                            let seq_res =
                                                                                                                                parse_rbrace(input,
                                                                                                                                             state,
                                                                                                                                             pos);
                                                                                                                            match seq_res
                                                                                                                                {
                                                                                                                                Matched(pos,
                                                                                                                                        _)
                                                                                                                                =>
                                                                                                                                {
                                                                                                                                    {
                                                                                                                                        let match_str =
                                                                                                                                            input.slice(start_pos,
                                                                                                                                                        pos);
                                                                                                                                        Matched(pos,
                                                                                                                                                {
                                                                                                                                                    Repeat(box() expression,
                                                                                                                                                           0,
                                                                                                                                                           max,
                                                                                                                                                           None)
                                                                                                                                                })
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                Failed
                                                                                                                                =>
                                                                                                                                Failed,
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    Failed
                                                                                                                    =>
                                                                                                                    Failed,
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    }
                                                                                }
                                                                                Failed
                                                                                =>
                                                                                Failed,
                                                                            }
                                                                        }
                                                                    };
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    parse_primary(input,
                                                                                  state,
                                                                                  pos),
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_primary<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Expr> {
    {
        let choice_res =
            {
                let start_pos = pos;
                {
                    let seq_res = parse_identifier(input, state, pos);
                    match seq_res {
                        Matched(pos, name) => {
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            {
                                                let seq_res =
                                                    match parse_string(input,
                                                                       state,
                                                                       pos) {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_returntype(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_equals(input,
                                                                                 state,
                                                                                 pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            };
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { RuleExpr(name) })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            };
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_literal(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = parse_class(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_dot(input, state, pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let match_str =
                                                            input.slice(start_pos,
                                                                        pos);
                                                        Matched(pos,
                                                                {
                                                                    AnyCharExpr
                                                                })
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_lparen(input, state,
                                                             pos);
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            parse_expression(input,
                                                                             state,
                                                                             pos);
                                                        match seq_res {
                                                            Matched(pos,
                                                                    expression)
                                                            => {
                                                                {
                                                                    let seq_res =
                                                                        parse_rparen(input,
                                                                                     state,
                                                                                     pos);
                                                                    match seq_res
                                                                        {
                                                                        Matched(pos,
                                                                                _)
                                                                        => {
                                                                            {
                                                                                let match_str =
                                                                                    input.slice(start_pos,
                                                                                                pos);
                                                                                Matched(pos,
                                                                                        {
                                                                                            expression
                                                                                        })
                                                                            }
                                                                        }
                                                                        Failed
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_action<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_braced(input, state, pos);
            match seq_res {
                Matched(pos, braced) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { braced })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_braced<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "{");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let choice_res =
                                                {
                                                    let seq_res =
                                                        parse_braced(input,
                                                                     state,
                                                                     pos);
                                                    match seq_res {
                                                        Matched(pos, _) => {
                                                            slice_eq(input,
                                                                     state,
                                                                     pos, "")
                                                        }
                                                        Failed => Failed,
                                                    }
                                                };
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed =>
                                                parse_nonBraceCharacters(input,
                                                                         state,
                                                                         pos),
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, ())
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "}");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_nonBraceCharacters<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res = parse_nonBraceCharacter(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1u {
            Matched(repeat_pos, ())
        } else { Failed }
    }
}
fn parse_nonBraceCharacter<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '{' | '}' => state.mark_failure(pos, "[{}]"),
            _ => Matched(next, ()),
        }
    } else { state.mark_failure(pos, "[{}]") }
}
fn parse_equals<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "=");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_colon<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ":");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_semicolon<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ";");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_slash<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_and<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "&");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_not<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "!");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_dollar<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "$");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_question<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "?");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_star<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "*");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_starstar<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "**");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_plus<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "+");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_plusplus<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "++");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_lparen<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "(");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_rparen<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ")");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_dot<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ".");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_returns<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "->");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_lbrace<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "{");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_rbrace<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "}");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_comma<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, ",");
        match seq_res {
            Matched(pos, _) => { parse___(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_integer<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<uint> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        if input.len() > pos {
                                            let ::std::str::CharRange {
                                                    ch, next } =
                                                input.char_range_at(pos);
                                            match ch {
                                                '0' ...'9' =>
                                                Matched(next, ()),
                                                _ =>
                                                state.mark_failure(pos,
                                                                   "[0-9]"),
                                            }
                                        } else {
                                            state.mark_failure(pos, "[0-9]")
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                if repeat_value.len() >= 1u {
                                    Matched(repeat_pos, ())
                                } else { Failed }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                from_str::<uint>(match_str).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, i) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { i })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifier<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_letter(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "_"),
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_letter(input,
                                                                         state,
                                                                         pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    parse_digit(input,
                                                                                state,
                                                                                pos);
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "_"),
                                                                }
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, chars) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { chars })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_literal<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, value) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "i") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, flags) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            LiteralExpr(value)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, string) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { string })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_doubleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            String::from_chars(s.as_slice())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let choice_res = parse_simpleDoubleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_hex4EscapeSequence(input,
                                                                     state,
                                                                     pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_hex8EscapeSequence(input,
                                                                             state,
                                                                             pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_eolEscapeSequence(input,
                                                                            state,
                                                                            pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleDoubleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState,
                                             pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\"");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\'");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_singleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\'");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            String::from_chars(s.as_slice())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let choice_res = parse_simpleSingleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_hex4EscapeSequence(input,
                                                                     state,
                                                                     pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_hex8EscapeSequence(input,
                                                                             state,
                                                                             pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_eolEscapeSequence(input,
                                                                            state,
                                                                            pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleSingleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState,
                                             pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\'");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_class<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Expr> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "[");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            match slice_eq(input, state, pos, "^") {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, inverted) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_classCharacterRange(input,
                                                                                      state,
                                                                                      pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_classCharacter(input,
                                                                                 state,
                                                                                 pos),
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, parts) => {
                                            {
                                                let seq_res =
                                                    slice_eq(input, state,
                                                             pos, "]");
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match slice_eq(input,
                                                                               state,
                                                                               pos,
                                                                               "i")
                                                                    {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        flags)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                CharSetExpr(inverted.is_some(),
                                                                                                            parts)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_classCharacterRange<'input>(input: &'input str,
                                     state: &mut ParseState, pos: uint) ->
 ParseResult<CharSetCase> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, state, pos);
            match seq_res {
                Matched(pos, begin) => {
                    {
                        let seq_res = slice_eq(input, state, pos, "-");
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_bracketDelimitedCharacter(input,
                                                                        state,
                                                                        pos);
                                    match seq_res {
                                        Matched(pos, end) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            CharSetCase{start:
                                                                            begin,
                                                                        end:
                                                                            end,}
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_classCharacter<'input>(input: &'input str, state: &mut ParseState,
                                pos: uint) -> ParseResult<CharSetCase> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_bracketDelimitedCharacter(input, state, pos);
            match seq_res {
                Matched(pos, char_) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos,
                                { CharSetCase{start: char_, end: char_,} })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_bracketDelimitedCharacter<'input>(input: &'input str,
                                           state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let choice_res =
            parse_simpleBracketDelimitedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hex2EscapeSequence(input, state,
                                                             pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_hex4EscapeSequence(input,
                                                                     state,
                                                                     pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    parse_hex8EscapeSequence(input,
                                                                             state,
                                                                             pos);
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed =>
                                                    parse_eolEscapeSequence(input,
                                                                            state,
                                                                            pos),
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleBracketDelimitedCharacter<'input>(input: &'input str,
                                                 state: &mut ParseState,
                                                 pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res = slice_eq(input, state, pos, "]");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_simpleEscapeSequence<'input>(input: &'input str,
                                      state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    {
                                        let choice_res =
                                            parse_digit(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    slice_eq(input, state,
                                                             pos, "x");
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "u");
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "U");
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    parse_eolChar(input,
                                                                                  state,
                                                                                  pos),
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = any_char(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match match_str.char_at(1)
                                                                {
                                                                'n' => '\n',
                                                                'r' => '\r',
                                                                't' => '\t',
                                                                x => x,
                                                            }
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_zeroEscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\0");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    parse_digit(input, state, pos);
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { 0u8 as char })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex2EscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\x");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        from_str_radix::<int>(match_str,
                                                                                              16)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex4EscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\u");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           state,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                from_str_radix::<int>(match_str,
                                                                                                                      16)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hex8EscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint) ->
 ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\U");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           state,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse_hexDigit(input,
                                                                                                       state,
                                                                                                       pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let seq_res =
                                                                                                    parse_hexDigit(input,
                                                                                                                   state,
                                                                                                                   pos);
                                                                                                match seq_res
                                                                                                    {
                                                                                                    Matched(pos,
                                                                                                            _)
                                                                                                    =>
                                                                                                    {
                                                                                                        {
                                                                                                            let seq_res =
                                                                                                                parse_hexDigit(input,
                                                                                                                               state,
                                                                                                                               pos);
                                                                                                            match seq_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        _)
                                                                                                                =>
                                                                                                                {
                                                                                                                    {
                                                                                                                        let seq_res =
                                                                                                                            parse_hexDigit(input,
                                                                                                                                           state,
                                                                                                                                           pos);
                                                                                                                        match seq_res
                                                                                                                            {
                                                                                                                            Matched(pos,
                                                                                                                                    _)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                {
                                                                                                                                    let match_str =
                                                                                                                                        input.slice(start_pos,
                                                                                                                                                    pos);
                                                                                                                                    Matched(pos,
                                                                                                                                            {
                                                                                                                                                from_str_radix::<int>(match_str,
                                                                                                                                                                      16)
                                                                                                                                            })
                                                                                                                                }
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            Failed,
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                Failed
                                                                                                                =>
                                                                                                                Failed,
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    Failed
                                                                                                    =>
                                                                                                    Failed,
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_eolEscapeSequence<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_eol(input, state, pos);
                        match seq_res {
                            Matched(pos, eol) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { '\n' })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_digit<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '0' ...'9' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9]"),
        }
    } else { state.mark_failure(pos, "[0-9]") }
}
fn parse_hexDigit<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '0' ...'9' | 'a' ...'f' | 'A' ...'F' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9a-fA-F]"),
        }
    } else { state.mark_failure(pos, "[0-9a-fA-F]") }
}
fn parse_letter<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let choice_res = parse_lowerCaseLetter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_upperCaseLetter(input, state, pos),
        }
    }
}
fn parse_lowerCaseLetter<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            'a' ...'z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[a-z]"),
        }
    } else { state.mark_failure(pos, "[a-z]") }
}
fn parse_upperCaseLetter<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            'A' ...'Z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[A-Z]"),
        }
    } else { state.mark_failure(pos, "[A-Z]") }
}
fn parse___<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_eol(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_comment(input, state, pos),
                            }
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_comment<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    {
        let choice_res = parse_singleLineComment(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_multiLineComment(input, state, pos),
        }
    }
}
fn parse_singleLineComment<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "//");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            parse_eolChar(input, state, pos);
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        any_char(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_multiLineComment<'input>(input: &'input str, state: &mut ParseState,
                                  pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "/*");
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let mut repeat_pos = pos;
                            loop  {
                                let pos = repeat_pos;
                                let step_res =
                                    {
                                        let seq_res =
                                            {
                                                let assert_res =
                                                    slice_eq(input, state,
                                                             pos, "*/");
                                                match assert_res {
                                                    Failed =>
                                                    Matched(pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                any_char(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match step_res {
                                    Matched(newpos, value) => {
                                        repeat_pos = newpos;
                                    }
                                    Failed => { break ; }
                                }
                            }
                            Matched(repeat_pos, ())
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            slice_eq(input, state, pos, "*/")
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_eol<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "\r\n");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "\r");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "\u2028");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "\u2029"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolChar<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '\n' | '\r' | '\u2028' | '\u2029' => Matched(next, ()),
            _ => state.mark_failure(pos, "[\n\r\u2028\u2029]"),
        }
    } else { state.mark_failure(pos, "[\n\r\u2028\u2029]") }
}
fn parse_whitespace<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            ' ' | '\t' | '\xa0' | '\ufeff' | '\u1680' | '\u180e' | '\u2000'
            ...'\u200a' | '\u202f' | '\u205f' | '\u3000' => Matched(next, ()),
            _ =>
            state.mark_failure(pos,
                               "[ \t\xa0\ufeff\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]"),
        }
    } else {
        state.mark_failure(pos,
                           "[ \t\xa0\ufeff\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]")
    }
}
pub fn grammar<'input>(input: &'input str) -> Result<Grammar, String> {
    let mut state = ParseState::new();
    match parse_grammar(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let expected = state.expected.to_string().escape_default();
    Err(format!("Error at {}: Expected {}" , pos_to_line (
                input , state . max_err_pos ) , expected))
}
