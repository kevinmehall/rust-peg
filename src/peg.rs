#![feature(quote, box_syntax, core, collections, rustc_private, env, io, os, path, unicode)]
extern crate syntax;

use std::env;
use std::iter::FromIterator;
use std::ffi::OsString;
use std::str;
use std::old_io::{stdin,stdout,stderr};
use std::old_io::fs::File;
use translate::{compile_grammar};

mod translate;
mod grammar;
mod rustast;
mod fake_extctxt;

fn print_usage(prog: &str) {
	println!("Usage: {} [file]", prog)
}

fn main() {
        let args_vec: Vec<OsString> = FromIterator::from_iter(env::args());
        let args: Vec<String> = args_vec.iter()
            .map(|s| s.clone().into_string().unwrap()).collect();

	let source_utf8 = match args.as_slice() {
		[ref progname, ref arg] if arg.as_slice() == "-h" => return print_usage(progname.as_slice()),
		[_, ref fname] => File::open(&Path::new(fname.as_slice())).read_to_end().unwrap(),
		[_] => stdin().read_to_end().unwrap(),
		[ref progname, ..] => return print_usage(progname.as_slice()),
		_ => panic!("No program name argument")
	};

	let source = str::from_utf8(source_utf8.as_slice()).unwrap();
	let grammar_def = grammar::grammar(source);

	match grammar_def {
		Ok(grammar) => {
			fake_extctxt::with_fake_extctxt(|e| {

				let ast = compile_grammar(e, &grammar);
				let mut out = stdout();

				out.write_line("// Generated by rust-peg. Do not edit.").unwrap();
				out.write_line("#![allow(non_snake_case, unused)]").unwrap();

				for item in ast.items.iter() {
					out.write_line(rustast::item_to_string(&**item).as_slice()).unwrap();
				}
			})
		}

		Err(msg) => {
			let mut e = stderr();
			(writeln!(&mut e, "Error parsing language specification: {}", msg)).unwrap();
			env::set_exit_status(1);
		}
	}
}
